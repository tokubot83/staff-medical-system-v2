# 共通DB構築後 作業再開指示書

作成日: 2025年9月28日
最終更新: 2025年10月11日（ProgressDashboard VoiceDrive実装タスク追加 - 6.3.10節）
対象: 医療職員管理システム開発チーム
前提: 共通DBの構築完了後に本書を参照

---

## 1. 作業再開前チェックリスト

### 環境確認
- [ ] 共通DB接続情報の受領
- [ ] VPNアクセス権限の確認
- [ ] 本番環境へのデプロイ権限
- [ ] VoiceDriveチームとの連携確認

### コードベース確認
- [ ] 最新のmainブランチをpull
- [ ] node_modules再インストール（`npm ci`）
- [ ] TypeScriptビルド確認（`npm run build`）

---

## 2. Step 1: 環境設定更新

### 2.1 本番環境設定ファイル作成
```bash
# .env.productionを作成
cp .env.example .env.production
```

### 2.2 環境変数設定
```env
# .env.production
DATABASE_URL=postgresql://[ユーザー名]:[パスワード]@[ホスト]:[ポート]/[データベース名]
FACILITY_DB_HOST=[共通DBホスト]
FACILITY_DB_PORT=5432
FACILITY_DB_NAME=[データベース名]
FACILITY_DB_USER=[ユーザー名]
FACILITY_DB_PASSWORD=[パスワード]

# 施設識別
DEFAULT_FACILITY_ID=espoir-tategami
MULTI_FACILITY_MODE=true

# Webhook設定（VoiceDrive連携用）
VOICEDRIVE_WEBHOOK_URL=[VoiceDriveチームから提供されるURL]
WEBHOOK_SECRET=[共有シークレットキー]
WEBHOOK_RETRY_COUNT=3
WEBHOOK_TIMEOUT=5000
```

---

## 3. Step 2: データベース接続確認

### 3.1 接続テスト実行
```bash
# DB接続テスト
npm run test:db:connection

# 期待される出力:
# ✅ データベース接続成功
# ✅ facilityマスターテーブル確認
# ✅ positionマスターテーブル確認
# ✅ staff_authorityテーブル確認
```

### 3.2 接続エラー時の対処
```bash
# ログ確認
tail -f logs/db-connection.log

# 一般的なエラー:
# - SSL証明書エラー → ssl: { rejectUnauthorized: false }を一時的に追加
# - タイムアウト → ファイアウォール設定確認
# - 認証エラー → 認証情報再確認
```

---

## 4. Step 3: マスターデータ投入

### 4.1 施設マスター登録
```sql
-- 実行するSQL（/sql/master-data/facilities.sql）
INSERT INTO facilities (facility_id, facility_name, facility_type, staff_count) VALUES
('obara-hospital', '医療法人 厚生会 小原病院', 'acute', 420),
('tategami-rehabilitation', '立神リハビリテーション温泉病院', 'rehabilitation', 180),
('espoir-tategami', '介護老人保健施設エスポワール立神', 'geriatric_health_facility', 150);
```

### 4.2 役職マスター登録
```bash
# マイグレーション実行
npm run db:migrate:production

# 確認
npm run db:verify:positions
```

### 4.3 エスポワール立神データ投入
```bash
# 33役職の一括登録
node scripts/import-espoir-positions.js

# 検証
node scripts/verify-espoir-data.js
```

---

## 5. Step 4: 統合テスト実施

### 5.1 Phase 3統合テスト
```bash
# 実環境での統合テスト
NODE_ENV=production node tests/integration/phase3-integration-test.js

# 確認項目:
# - 小原病院: 9役職
# - 立神リハビリ: 12役職（統括主任レベル7）
# - エスポワール立神: 33役職
```

### 5.2 エスポワール立神特化テスト
```bash
# Day 1-3統合テスト実行
npm run test:espoir:complete

# 個別実行
node tests/integration/run-integration-test.ts  # Day 1
node tests/integration/day2-approval-flow-test.ts  # Day 2
node tests/integration/day3-load-test.ts  # Day 3（作成要）
```

### 5.3 兼任職員権限テスト
```bash
# 特定職員のテスト
node tests/verify-dual-position.js --staff-id ESP_003
node tests/verify-dual-position.js --staff-id ESP_004
```

---

## 6. Step 5: VoiceDrive連携確認

### 6.1 Webhook疎通確認
```bash
# テスト送信
curl -X POST $VOICEDRIVE_WEBHOOK_URL \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Secret: $WEBHOOK_SECRET" \
  -d '{"test": true, "facility": "espoir-tategami"}'
```

### 6.2 データ同期テスト
```bash
# 同期テスト実行
node scripts/test-voicedrive-sync.js

# ログ確認
tail -f logs/voicedrive-sync.log
```

### 6.3 OrganizationAnalytics API統合テスト

**前提条件**:
- ✅ API実装完了（2025年10月10日）
- ✅ 単体テスト30件全て成功（モックデータ）
- ✅ API仕様書承認済み（VD-APPROVAL-2025-1010-001）
- ✅ 実装報告書作成済み（mcp-shared/docs/organization-analytics_API実装完了報告_20251010.md）

#### 6.3.1 環境変数設定
```bash
# .env.productionに追加
ORGANIZATION_ANALYTICS_API_KEY=[openssl rand -hex 32で生成したAPI Key]

# VoiceDrive側の設定確認（VoiceDriveチームに共有）
# MEDICAL_SYSTEM_API_URL=https://medical.example.com/api/v2
# MEDICAL_SYSTEM_API_KEY=[上記のORGANIZATION_ANALYTICS_API_KEYと同じ値]
```

**API Key生成方法**:
```bash
# ランダムなAPI Keyを生成
openssl rand -hex 32

# 生成されたAPI Keyを.env.productionとVoiceDriveチームに共有
```

#### 6.3.2 実データでAPI動作確認
```bash
# API-1: 部門マスタ取得テスト
curl -X GET "http://localhost:3000/api/v2/departments?facilityId=facility-001" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": [
#     {
#       "departmentId": "dept-001",
#       "departmentCode": "D001",
#       "departmentName": "内科",
#       "facilityId": "facility-001",
#       "facilityCode": "F001",
#       "facilityName": "小原病院",
#       "parentDepartmentId": null,
#       "level": 1,
#       "createdAt": "2024-01-01T00:00:00.000Z",
#       "updatedAt": "2024-01-01T00:00:00.000Z"
#     }
#   ],
#   "meta": {
#     "total": 9,
#     "timestamp": "2025-10-10T12:00:00.000Z"
#   }
# }

# API-2: 職員数取得テスト
curl -X GET "http://localhost:3000/api/v2/employees/count?facilityId=facility-001" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": {
#     "totalCount": 120,
#     "byDepartment": [
#       {
#         "departmentId": "dept-001",
#         "departmentCode": "D001",
#         "departmentName": "内科",
#         "count": 50
#       },
#       {
#         "departmentId": "dept-002",
#         "departmentCode": "D002",
#         "departmentName": "外科",
#         "count": 70
#       }
#     ]
#   },
#   "meta": {
#     "timestamp": "2025-10-10T12:00:00.000Z",
#     "filters": {
#       "facilityId": "facility-001",
#       "departmentId": null
#     }
#   }
# }

# 注意: Phase 1では雇用形態別カウント未対応
# 理由: employmentTypeフィールド未実装（Phase 2で対応予定）
```

#### 6.3.3 エラーハンドリングテスト
```bash
# 401 Unauthorized（API Key未提供）
curl -X GET "http://localhost:3000/api/v2/departments"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"API Key is required"}}

# 401 Unauthorized（不正なAPI Key）
curl -X GET "http://localhost:3000/api/v2/departments" \
  -H "X-API-Key: invalid-key"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"Invalid API Key"}}

# 400 Bad Request（Phase 1未対応パラメータ）
curl -X GET "http://localhost:3000/api/v2/departments?isActive=true" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"
# 期待: {"error":{"code":"BAD_REQUEST","message":"Invalid query parameter","details":"isActive filter is not supported in Phase 1"}}

# 429 Rate Limit超過テスト（100回超過でエラー）
for i in {1..105}; do
  curl -X GET "http://localhost:3000/api/v2/departments" \
    -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}" \
    -H "X-Forwarded-For: 192.168.1.100"
done
# 101回目以降: {"error":{"code":"RATE_LIMIT_EXCEEDED","message":"Too many requests"}}
```

#### 6.3.4 VoiceDriveチームとの統合テスト
```bash
# VoiceDriveチームに以下を共有:
# - APIエンドポイントURL: https://medical.example.com/api/v2
# - VoiceDrive用APIキー: [Slackで共有]
# - API仕様書: mcp-shared/docs/organization-analytics_API仕様書_20251010.yaml

# VoiceDriveチーム側での確認事項:
# 1. OrganizationAnalyticsServiceでAPIを呼び出し
# 2. 組織健康度指標が正常に計算されるか確認
# 3. 部門別活性度が正常に表示されるか確認
```

#### 6.3.5 統合テスト完了基準
- [ ] API-1（部門マスタ）が実データで正常動作
- [ ] API-2（職員総数）が実データで正常動作
- [ ] Rate Limitヘッダーが正常に返却される
- [ ] エラーレスポンスが仕様通り
- [ ] VoiceDrive OrganizationAnalyticsページで表示確認

**推定工数**: 2日間（DB構築後）

**関連ドキュメント**:
- API仕様書: `mcp-shared/docs/organization-analytics_API仕様書_20251010.yaml`
- 承認書: `mcp-shared/docs/organization-analytics_API仕様書承認済み_20251010.md`
- 実装報告書: `mcp-shared/docs/organization-analytics_API実装完了報告_20251010.md`（✅ 完成）

**実装済みファイル**:
- `src/lib/middleware/api-key-auth.ts` - API Key認証ミドルウェア
- `src/lib/middleware/rate-limiter.ts` - Rate Limitミドルウェア
- `src/app/api/v2/departments/route.ts` - 部門マスタAPI
- `src/app/api/v2/employees/count/route.ts` - 職員数API
- テストファイル4件（30テスト全て成功）

---

### 6.3.5 ExecutiveReports API統合テスト

**概要**:
ExecutiveReportsページは、OrganizationAnalyticsと同じAPI（`GET /api/v2/employees/count`）を使用するため、追加のAPI実装は不要。VoiceDrive側でレスポンス変換を実装。

**前提条件**:
- ✅ API実装完了（2025年10月10日）- OrganizationAnalytics用と共通
- ✅ API利用承認済み（MEDICAL-APPROVAL-2025-1011-001）
- ✅ 統合テストスケジュール確定（2025年10月25日）

#### 統合テスト日程

**日時**: 2025年10月25日（金）14:00-16:00
**所要時間**: 2時間
**参加者**: VoiceDriveチーム開発担当2名 + 医療システムチーム担当者
**実施方法**: オンライン（Teams/Zoom）

#### テストシナリオ（5シナリオ、20テストケース）

**シナリオ1: API認証テスト**（15分）
- TC-1.1: 正常な認証（JWT + API Key）
- TC-1.2: JWT Token無効
- TC-1.3: API Key無効
- TC-1.4: 認証ヘッダなし

**シナリオ2: レスポンス形式検証**（20分）
- TC-2.1: 全職員数取得
- TC-2.2: 部門別カウント取得
- TC-2.3: 施設絞り込み
- TC-2.4: 部門絞り込み
- TC-2.5: タイムスタンプ検証

**シナリオ3: エラーハンドリング検証**（25分）
- TC-3.1: Rate Limit超過
- TC-3.2: DB接続エラー（任意）
- TC-3.3: 不正なクエリパラメータ
- TC-3.4: 存在しない施設ID

**シナリオ4: パフォーマンステスト**（30分）
- TC-4.1: 単発リクエスト応答時間（< 500ms）
- TC-4.2: 50リクエスト連続実行
- TC-4.3: 同時接続テスト（5並列）
- TC-4.4: 大量データ時の応答時間（< 1000ms）

**シナリオ5: VoiceDrive統合テスト**（30分）
- TC-5.1: KPI参加率計算
- TC-5.2: 月次レポート生成
- TC-5.3: キャッシュ機能
- TC-5.4: キャッシュ有効期限

#### 医療システム側の準備事項

```bash
# テスト環境URL確認
https://medical-staging.example.com

# テストデータ準備（推奨、既存データで十分な場合は不要）
# - 職員総数: 150名程度
# - 部門: 5部門以上
# - 施設: 2施設以上
```

**合格基準**:
- [ ] 全20テストケース成功
- [ ] API応答時間 < 500ms（単発）、< 1000ms（大量データ）
- [ ] Rate Limit正常動作確認
- [ ] VoiceDrive ExecutiveReportServiceの正常動作確認

**推定工数**: 2時間（2025年10月25日）

**実装状況**:
- ✅ API実装完了（2025-10-10）- OrganizationAnalyticsと共通
- ✅ API利用承認（2025-10-11）
- ✅ 統合テストスケジュール確定（10月25日）
- ⏳ 統合テスト実施待ち（10月25日予定）

**関連ドキュメント**:
- [executive-reports_医療システム確認結果_20251011.md](../mcp-shared/docs/executive-reports_医療システム確認結果_20251011.md)
- [executive-reports_医療システム承認回答_20251011.md](../mcp-shared/docs/executive-reports_医療システム承認回答_20251011.md)
- VD-SCHEDULE-2025-1011-001（VoiceDriveチーム作成）

---

### 6.3.6 BoardPreparation & VoiceDrive側実装タスク

**概要**:
BoardPreparationページも、OrganizationAnalytics/ExecutiveReportsと同じAPI（`GET /api/v2/employees/count`）を使用するため、医療システム側で追加のAPI実装は不要。VoiceDrive側で以下の実装が必要。

**医療システム側の対応**:
- ✅ API実装完了（2025年10月10日）- OrganizationAnalytics用と共通
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要

**VoiceDrive側の実装タスク**:

#### タスク1: ExecutiveReports レスポンス変換実装

```typescript
// VoiceDrive: src/services/MedicalSystemClient.ts
export async function getEmployeeCountForReports() {
  const response = await fetch('/api/v2/employees/count', {
    headers: {
      'Authorization': `Bearer ${JWT_TOKEN}`,
      'X-API-Key': API_KEY
    }
  });

  const data = await response.json();

  // レスポンス変換
  return {
    totalEmployees: data.data.totalCount,  // ← フィールド名変換
    byDepartment: data.data.byDepartment.reduce((acc, dept) => {
      acc[dept.departmentName] = dept.count;
      return acc;
    }, {}),
    activeOnly: true,
    calculatedAt: data.meta.timestamp
  };
}
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🔴 HIGH

---

#### タスク2: ReportDistributionGroup テーブル作成

```prisma
// VoiceDrive: schema.prisma
model ReportDistributionGroup {
  id          String   @id @default(cuid())
  groupKey    String   @unique              // "board-members", "executives"
  groupName   String                        // "理事会メンバー", "経営幹部"
  description String?

  // メンバー管理（医療システムのEmployee IDを格納）
  memberIds   Json                           // ["EMP001", "EMP002", ...]

  // 配布設定
  autoSend    Boolean  @default(false)       // 自動配布ON/OFF
  sendTiming  String?                        // "immediately", "scheduled"

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("report_distribution_groups")
}
```

**マイグレーション**:
```bash
npx prisma migrate dev --name add_report_distribution_group
```

**初期データ投入**:
```typescript
// VoiceDrive: prisma/seed.ts
await prisma.reportDistributionGroup.createMany({
  data: [
    {
      groupKey: 'board-members',
      groupName: '理事会メンバー',
      memberIds: ['EMP001', 'EMP002', 'EMP003'],
      autoSend: true,
      sendTiming: 'immediately'
    },
    {
      groupKey: 'executives',
      groupName: '経営幹部',
      memberIds: ['EMP010', 'EMP011', 'EMP012', 'EMP013'],
      autoSend: false
    }
  ]
});
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🔴 HIGH

---

#### タスク3: S3 Lifecycle Policy設定（全期間保存）

```json
// AWS S3コンソール or AWS CLI
{
  "Rules": [
    {
      "Id": "BoardMeetingDocuments-Lifecycle",
      "Prefix": "board-meetings/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 1095, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存
      // 理由: Phase 18 VoiceAnalytics、Phase 19 CultureDevelopmentと同じポリシー
    },
    {
      "Id": "ExecutiveReports-Lifecycle",
      "Prefix": "reports/board/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 1095, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存（職員情報含む）
    },
    {
      "Id": "ChairmanProposals-Lifecycle",
      "Prefix": "chairman-proposals/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 365, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存
    }
  ]
}
```

**設定方法**:
```bash
# AWS CLI
aws s3api put-bucket-lifecycle-configuration \
  --bucket voicedrive-documents \
  --lifecycle-configuration file://lifecycle-policy.json
```

**実装期間**: 0.5日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: BoardPreparation 統合実装

VoiceDrive側で以下のテーブルを実装（医療システム側は関与なし）:

```prisma
// VoiceDrive: schema.prisma

model BoardMeeting {
  id                  String    @id @default(cuid())
  meetingDate         DateTime
  meetingType         String    // 'regular' | 'extraordinary'
  fiscalYear          Int
  quarterNumber       Int?
  status              String    @default("planning") // 'planning' | 'confirmed' | 'completed'

  agendas             BoardMeetingAgenda[]

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@map("board_meetings")
}

model BoardAgendaCandidateSelection {
  id                  String    @id @default(cuid())
  agendaId            String
  selectedBy          String    // User.id
  selectionReason     String?
  priorityScore       Int       @default(5)
  selectedAt          DateTime  @default(now())

  agenda              BoardMeetingAgenda @relation(fields: [agendaId], references: [id])
  selector            User      @relation(fields: [selectedBy], references: [id])

  @@unique([agendaId, selectedBy])
  @@map("board_agenda_candidate_selections")
}

model ChairmanProposal {
  id                  String    @id @default(cuid())
  proposalTitle       String
  proposalType        String    // 'agenda-addition' | 'agenda-removal' | 'priority-change'
  targetAgendaId      String?
  proposalReason      String
  proposedBy          String    // User.id
  proposedAt          DateTime  @default(now())
  status              String    @default("pending") // 'pending' | 'approved' | 'rejected'

  targetAgenda        BoardMeetingAgenda? @relation(fields: [targetAgendaId], references: [id])
  proposer            User      @relation(fields: [proposedBy], references: [id])

  @@map("chairman_proposals")
}

// BoardMeetingAgendaテーブルに準備状況フィールドを追加
model BoardMeetingAgenda {
  // ... 既存フィールド

  // 🆕 準備状況管理フィールド
  preparationStatus          String?   @default("not-started") // 'not-started' | 'in-progress' | 'review' | 'completed'
  documentDraftStatus        String?   @default("not-started")
  presentationDraftStatus    String?   @default("not-started")
  documentS3Key              String?
  presentationS3Key          String?
  documentUploadedAt         DateTime?
  presentationUploadedAt     DateTime?
  responsibleDepartment      String?
  responsibleUserId          String?
  dueDate                    DateTime?

  candidateSelections        BoardAgendaCandidateSelection[]
  chairmanProposals          ChairmanProposal[]

  @@map("board_meeting_agendas")
}

// Userテーブルにリレーション追加
model User {
  // ... 既存フィールド

  agendaCandidateSelections  BoardAgendaCandidateSelection[]
  chairmanProposals          ChairmanProposal[]

  @@map("users")
}
```

**実装期間**: 5日（共通DB構築後）
**優先度**: 🟡 MEDIUM（ExecutiveReportsの後）

---

#### VoiceDrive実装スケジュール

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: APIレスポンス変換 | 1日 | 🔴 HIGH | ExecutiveReports/BoardPreparation共通 |
| **タスク2**: ReportDistributionGroup | 1日 | 🔴 HIGH | ExecutiveReports用 |
| **タスク3**: S3 Lifecycle Policy | 0.5日 | 🟡 MEDIUM | インフラ設定 |
| **タスク4**: BoardPreparation DB設計 | 5日 | 🟡 MEDIUM | Phase 2で実装 |

**合計**: 7.5日（共通DB構築後に実施）

**関連ドキュメント**:
- [board-preparation_医療システム確認結果_20251011.md](../mcp-shared/docs/board-preparation_医療システム確認結果_20251011.md)
- [executive-reports_医療システム確認結果_20251011.md](../mcp-shared/docs/executive-reports_医療システム確認結果_20251011.md)
- Phase 18 VoiceAnalytics、Phase 19 CultureDevelopment（全期間保存ポリシー参考）

---

### 6.3.7 BoardAgendaReview VoiceDrive側実装タスク

**概要**:
BoardAgendaReviewページは、Level 17（戦略企画部長・人事部長）が準備した理事会議題をLevel 18（理事長・法人事務局長）が事前確認・レビューする機能。完全にVoiceDrive内部のワークフローであり、医療システム側のデータは一切使用しない。

**医療システム側の対応**:
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要（VoiceDrive内部ワークフローのため）

**VoiceDrive側の実装タスク**:

#### タスク1: BoardMeetingAgendaテーブル拡張（理事長レビュー用）

```sql
-- VoiceDrive: マイグレーション
ALTER TABLE `board_meeting_agendas`
ADD COLUMN `key_points` JSON NULL AFTER `document_urls`,
ADD COLUMN `expected_discussion` TEXT NULL AFTER `key_points`,
ADD COLUMN `required_decision` TEXT NULL AFTER `expected_discussion`,
ADD COLUMN `chairman_review` VARCHAR(191) NULL DEFAULT 'pending' AFTER `required_decision`,
ADD COLUMN `chairman_comment` TEXT NULL AFTER `chairman_review`,
ADD COLUMN `chairman_reviewed_by` VARCHAR(191) NULL AFTER `chairman_comment`,
ADD COLUMN `chairman_reviewed_at` DATETIME(3) NULL AFTER `chairman_reviewed_by`;

-- インデックス追加
CREATE INDEX `idx_bma_chairman_review` ON `board_meeting_agendas`(`chairman_review`);
CREATE INDEX `idx_bma_chairman_reviewed_at` ON `board_meeting_agendas`(`chairman_reviewed_at`);
CREATE INDEX `idx_bma_meeting_review` ON `board_meeting_agendas`(`board_meeting_id`, `chairman_review`);

-- 外部キー制約追加
ALTER TABLE `board_meeting_agendas`
ADD CONSTRAINT `fk_bma_chairman_reviewed_by`
FOREIGN KEY (`chairman_reviewed_by`) REFERENCES `users`(`id`)
ON DELETE SET NULL ON UPDATE CASCADE;
```

**Prismaスキーマ**:
```prisma
// VoiceDrive: schema.prisma
model BoardMeetingAgenda {
  // ... 既存フィールド（BoardPreparationで追加済み）

  // 🆕 理事長レビュー用フィールド（BoardAgendaReview）
  keyPoints            Json?      // ["スコア74点(前期比+6点)", ...]
  expectedDiscussion   String?    @db.Text
  requiredDecision     String?    @db.Text
  chairmanReview       String?    @default("pending") // 'pending' | 'approved' | 'needs_revision' | 'rejected'
  chairmanComment      String?    @db.Text
  chairmanReviewedBy   String?
  chairmanReviewedAt   DateTime?

  chairmanReviewer     User?      @relation("AgendaChairmanReviewer", fields: [chairmanReviewedBy], references: [id])

  @@map("board_meeting_agendas")
}

model User {
  // ... 既存フィールド

  reviewedAgendas      BoardMeetingAgenda[]  @relation("AgendaChairmanReviewer")

  @@map("users")
}
```

**実装期間**: 1日（共通DB構築後、BoardPreparationテーブル作成後）
**優先度**: 🟡 MEDIUM（BoardPreparationの後）

---

#### タスク2: BoardAgendaReviewService実装

```typescript
// VoiceDrive: src/services/BoardAgendaReviewService.ts
class BoardAgendaReviewService {
  // 次回理事会の議題一覧を取得
  async getAgendasForReview(
    boardMeetingId: string
  ): Promise<BoardMeetingAgenda[]> {
    return await prisma.boardMeetingAgenda.findMany({
      where: { boardMeetingId },
      orderBy: { agendaOrder: 'asc' },
      include: {
        presenter: true,
        chairmanReviewer: true
      }
    });
  }

  // 理事長レビューを実行
  async submitChairmanReview(
    agendaId: string,
    reviewData: {
      status: 'approved' | 'needs_revision' | 'rejected';
      comment?: string;
      reviewedBy: string;
    }
  ): Promise<BoardMeetingAgenda> {
    // バリデーション1: 修正依頼・却下時はコメント必須
    if (
      (reviewData.status === 'needs_revision' ||
       reviewData.status === 'rejected') &&
      !reviewData.comment
    ) {
      throw new Error('修正依頼または却下時はコメントが必須です');
    }

    // バリデーション2: レビュー済み議題は再レビュー不可
    const agenda = await prisma.boardMeetingAgenda.findUnique({
      where: { id: agendaId }
    });

    if (agenda.chairmanReview && agenda.chairmanReview !== 'pending') {
      throw new Error('この議題は既にレビュー済みです');
    }

    // バリデーション3: Level 18権限チェック
    const reviewer = await prisma.user.findUnique({
      where: { id: reviewData.reviewedBy }
    });

    if (reviewer.permissionLevel < 18) {
      throw new ForbiddenError('理事会議題レビューの権限がありません');
    }

    // レビュー実行
    const result = await prisma.boardMeetingAgenda.update({
      where: { id: agendaId },
      data: {
        chairmanReview: reviewData.status,
        chairmanComment: reviewData.comment,
        chairmanReviewedBy: reviewData.reviewedBy,
        chairmanReviewedAt: new Date()
      }
    });

    // Level 17への通知送信
    await this.notifyLevel17(agendaId, reviewData);

    // 監査ログ記録
    await auditLog.create({
      userId: reviewData.reviewedBy,
      action: 'CHAIRMAN_REVIEW_AGENDA',
      resource: agendaId,
      details: { status: reviewData.status, comment: reviewData.comment }
    });

    return result;
  }

  // Level 17への通知
  async notifyLevel17(
    agendaId: string,
    reviewResult: { status: string; comment?: string }
  ): Promise<void> {
    const agenda = await prisma.boardMeetingAgenda.findUnique({
      where: { id: agendaId },
      include: { presenter: true }
    });

    const notificationMessage =
      reviewResult.status === 'approved'
        ? `理事会議題「${agenda.item}」が承認されました。`
        : reviewResult.status === 'needs_revision'
        ? `理事会議題「${agenda.item}」の修正依頼があります。理事長コメント: ${reviewResult.comment}`
        : `理事会議題「${agenda.item}」が却下されました。理事長コメント: ${reviewResult.comment}`;

    // 議題作成者（Level 17）に通知
    await prisma.notification.create({
      data: {
        userId: agenda.presenterId,
        category: 'board_agenda_review',
        title: '理事会議題レビュー結果',
        message: notificationMessage,
        link: '/board-preparation',
        priority: reviewResult.status === 'approved' ? 'normal' : 'high',
        isRead: false
      }
    });

    // Level 17全員にも通知
    const level17Users = await prisma.user.findMany({
      where: { permissionLevel: { gte: 17, lt: 18 } }
    });

    for (const user of level17Users) {
      if (user.id !== agenda.presenterId) {
        await prisma.notification.create({
          data: {
            userId: user.id,
            category: 'board_agenda_review',
            title: '理事会議題レビュー結果（参考）',
            message: notificationMessage,
            link: '/board-preparation',
            priority: 'normal',
            isRead: false
          }
        });
      }
    }
  }

  // レビュー統計を取得
  async getReviewStats(boardMeetingId: string): Promise<ReviewStats> {
    const agendas = await prisma.boardMeetingAgenda.findMany({
      where: { boardMeetingId }
    });

    const totalAgendas = agendas.length;
    const approvedCount = agendas.filter(a => a.chairmanReview === 'approved').length;
    const needsRevisionCount = agendas.filter(a => a.chairmanReview === 'needs_revision').length;
    const rejectedCount = agendas.filter(a => a.chairmanReview === 'rejected').length;
    const pendingCount = agendas.filter(a => !a.chairmanReview || a.chairmanReview === 'pending').length;

    return {
      totalAgendas,
      approvedCount,
      needsRevisionCount,
      rejectedCount,
      pendingCount,
      completionRate: ((approvedCount + needsRevisionCount + rejectedCount) / totalAgendas) * 100
    };
  }
}
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク3: API実装（5エンドポイント）

```typescript
// VoiceDrive: src/app/api/board-agenda-review/[...]/route.ts

// 1. GET /api/board-agenda-review/:boardMeetingId/agendas - 議題一覧取得
export async function GET(
  req: Request,
  { params }: { params: { boardMeetingId: string } }
) {
  const user = await authenticate(req);
  if (user.permissionLevel < 18) {
    return Response.json({ error: 'Forbidden' }, { status: 403 });
  }

  const agendas = await service.getAgendasForReview(params.boardMeetingId);
  return Response.json(agendas);
}

// 2. GET /api/board-agenda-review/agendas/:agendaId - 議題詳細取得
// 3. POST /api/board-agenda-review/agendas/:agendaId/review - 理事長レビュー実行
// 4. GET /api/board-agenda-review/:boardMeetingId/stats - レビュー統計取得
// 5. GET /api/board-agenda-review/next-meeting - 次回理事会情報取得
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: フロントエンド実装

```typescript
// VoiceDrive: コンポーネント実装

// 1. AgendaReviewCard - 議題レビューカード
// 2. ReviewStatusBadge - レビューステータスバッジ
const getStatusStyle = (status: string) => {
  switch (status) {
    case 'pending':
      return { bg: 'yellow-100', text: 'yellow-800', label: 'レビュー待ち' };
    case 'approved':
      return { bg: 'green-100', text: 'green-800', label: '承認済み' };
    case 'needs_revision':
      return { bg: 'orange-100', text: 'orange-800', label: '修正依頼' };
    case 'rejected':
      return { bg: 'red-100', text: 'red-800', label: '却下' };
  }
};

// 3. ReviewCommentDialog - レビューコメント入力ダイアログ
// 4. MeetingSummaryCards - 理事会サマリーカード

// 5. useBoardAgendaReview - カスタムフック
const useBoardAgendaReview = (boardMeetingId: string) => {
  const { data: agendas, isLoading, error } = useSWR(
    `/api/board-agenda-review/${boardMeetingId}/agendas`,
    fetcher
  );

  const submitReview = async (
    agendaId: string,
    status: 'approved' | 'needs_revision' | 'rejected',
    comment?: string
  ) => {
    await fetch(`/api/board-agenda-review/agendas/${agendaId}/review`, {
      method: 'POST',
      body: JSON.stringify({ status, comment })
    });
    mutate();
  };

  return { agendas, isLoading, error, submitReview };
};
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク5: 運用実装（レビュー期限管理・監視）

```typescript
// VoiceDrive: バッチ処理実装

// 1. 理事会3日前にリマインダー通知
async function sendReviewReminder() {
  const threeDaysLater = new Date();
  threeDaysLater.setDate(threeDaysLater.getDate() + 3);

  const upcomingMeetings = await prisma.boardMeeting.findMany({
    where: {
      meetingDate: { gte: new Date(), lte: threeDaysLater },
      status: 'planning'
    },
    include: { agendas: true }
  });

  for (const meeting of upcomingMeetings) {
    const pendingAgendas = meeting.agendas.filter(
      a => a.chairmanReview === 'pending'
    );

    if (pendingAgendas.length > 0) {
      // Level 18に通知
      await notifyLevel18({
        title: '理事会議題レビューのリマインダー',
        message: `${meeting.meetingDate.toLocaleDateString('ja-JP')}の理事会まで3日です。未レビュー議題が${pendingAgendas.length}件あります。`,
        priority: 'high'
      });
    }
  }
}

// 毎日午前9時に実行（cron: 0 9 * * *）

// 2. レビュー完了率の監視
async function monitorReviewCompletionRate() {
  const upcomingMeetings = await prisma.boardMeeting.findMany({
    where: {
      meetingDate: { gte: new Date() },
      status: 'planning'
    },
    include: { agendas: true }
  });

  for (const meeting of upcomingMeetings) {
    const totalAgendas = meeting.agendas.length;
    const reviewedAgendas = meeting.agendas.filter(
      a => a.chairmanReview && a.chairmanReview !== 'pending'
    ).length;

    const completionRate = reviewedAgendas / totalAgendas;
    const daysUntilMeeting = Math.ceil(
      (meeting.meetingDate.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)
    );

    // アラート条件: 理事会まで3日を切り、レビュー完了率80%未満
    if (daysUntilMeeting < 3 && completionRate < 0.8) {
      await notifySlack({
        channel: '#board-meeting-alerts',
        message: `:warning: 理事会まで${daysUntilMeeting}日ですが、議題レビュー完了率が${(completionRate * 100).toFixed(1)}%です（${reviewedAgendas}/${totalAgendas}件）`
      });
    }
  }
}

// 毎日午前10時、午後3時に実行
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟢 LOW（Phase 2で実装）

---

#### VoiceDrive実装スケジュール（BoardAgendaReview）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: BoardMeetingAgendaテーブル拡張 | 1日 | 🟡 MEDIUM | BoardPreparation後に実装 |
| **タスク2**: BoardAgendaReviewService | 2日 | 🟡 MEDIUM | レビュー実行・通知機能 |
| **タスク3**: API実装（5エンドポイント） | 1日 | 🟡 MEDIUM | Level 18権限チェック |
| **タスク4**: フロントエンド実装 | 2日 | 🟡 MEDIUM | 4コンポーネント + 1フック |
| **タスク5**: 運用実装（リマインダー・監視） | 1日 | 🟢 LOW | Phase 2で実装 |

**合計**: 7日（共通DB構築後に実施、BoardPreparation実装後）

**テスト要件**:
- ユニットテスト: 15ケース以上
- API統合テスト: 10ケース以上
- エンドツーエンドテスト: 1ケース（Level 17 → Level 18 ワークフロー全体）

**関連ドキュメント**:
- [board-agenda-review_医療システム確認結果_20251011.md](../mcp-shared/docs/board-agenda-review_医療システム確認結果_20251011.md)
- [board-preparation_医療システム確認結果_20251011.md](../mcp-shared/docs/board-preparation_医療システム確認結果_20251011.md)
- BoardPreparationとのワークフロー連携（Level 17 → Level 18）

---

### 6.3.8 BoardDecisionFollow VoiceDrive側実装タスク

**概要**:
BoardDecisionFollowページは、理事会で決定された事項の実施進捗を追跡・管理する機能。VoiceDrive内部のプロジェクト管理機能であり、医療システム側のデータは既存API（facilities, departments）のみ使用。

**医療システム側の対応**:
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要（VoiceDrive内部プロジェクト管理機能のため）
- ✅ 既存API利用（GET /api/v2/facilities, GET /api/v2/departments）

**VoiceDrive側の実装タスク**:

#### タスク1: データベース構築（3テーブル新規作成）

```prisma
// VoiceDrive: schema.prisma

// 1. 理事会決定事項テーブル
model BoardDecision {
  id                      String    @id @default(cuid())
  boardMeetingId          String    @map("board_meeting_id")
  meetingDate             DateTime  @map("meeting_date")
  title                   String
  category                String    // "システム導入", "人事制度", "IT・システム", "人材育成"
  description             String    @db.Text
  decision                String    @db.Text
  implementationDeadline  DateTime  @map("implementation_deadline")
  responsibleDept         String    @map("responsible_dept")  // 担当部門名（キャッシュ）
  responsibleDeptId       String?   @map("responsible_dept_id")  // 医療システム部門ID
  affectedFacilities      Json      @map("affected_facilities")  // 影響施設ID配列
  status                  String    @default("on_track")  // "completed", "on_track", "at_risk", "delayed"
  progress                Int       @default(0)  // 0-100
  lastUpdate              DateTime  @default(now()) @map("last_update")
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  boardMeeting            BoardMeeting @relation("BoardDecisions", fields: [boardMeetingId], references: [id], onDelete: Cascade)
  milestones              BoardDecisionMilestone[]
  facilityImplementations BoardDecisionFacilityImplementation[]

  @@index([boardMeetingId])
  @@index([status])
  @@index([implementationDeadline])
  @@index([category])
  @@map("board_decisions")
}

// 2. マイルストーンテーブル
model BoardDecisionMilestone {
  id                String        @id @default(cuid())
  boardDecisionId   String        @map("board_decision_id")
  title             String
  deadline          DateTime
  status            String        @default("pending")  // "completed", "in_progress", "pending", "delayed"
  assignee          String
  assigneeId        String?       @map("assignee_id")
  sortOrder         Int           @default(0) @map("sort_order")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  completedAt       DateTime?     @map("completed_at")

  boardDecision     BoardDecision @relation(fields: [boardDecisionId], references: [id], onDelete: Cascade)

  @@index([boardDecisionId])
  @@index([status])
  @@index([deadline])
  @@index([sortOrder])
  @@map("board_decision_milestones")
}

// 3. 施設別実施状況テーブル
model BoardDecisionFacilityImplementation {
  id                String        @id @default(cuid())
  boardDecisionId   String        @map("board_decision_id")
  facilityId        String        @map("facility_id")  // 医療システム施設ID
  facilityName      String        @map("facility_name")  // 施設名（キャッシュ）
  status            String        @default("not_started")  // "completed", "in_progress", "not_started"
  progress          Int           @default(0)  // 0-100
  note              String?
  startedAt         DateTime?     @map("started_at")
  completedAt       DateTime?     @map("completed_at")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  boardDecision     BoardDecision @relation(fields: [boardDecisionId], references: [id], onDelete: Cascade)

  @@unique([boardDecisionId, facilityId])
  @@index([boardDecisionId])
  @@index([facilityId])
  @@index([status])
  @@map("board_decision_facility_implementations")
}

// 4. BoardMeeting リレーション追加
model BoardMeeting {
  // ... 既存フィールド

  decisions           BoardDecision[]      @relation("BoardDecisions")
}
```

**マイグレーション実行**:
```bash
npx prisma migrate dev --name add_board_decision_follow_tables
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM（BoardAgendaReviewの後）

---

#### タスク2: BoardDecisionFollowService実装

```typescript
// VoiceDrive: src/services/BoardDecisionFollowService.ts
class BoardDecisionFollowService {
  // 決定事項作成（医療システムAPIから施設名をキャッシュ）
  async createDecision(data: {
    boardMeetingId: string;
    title: string;
    category: string;
    description: string;
    decision: string;
    implementationDeadline: Date;
    responsibleDept: string;
    affectedFacilities: string[];
    milestones: { title: string; deadline: Date; assignee: string; }[];
  }): Promise<BoardDecision> {
    // 医療システムから施設マスタを取得
    const facilitiesResponse = await fetch(`${MEDICAL_SYSTEM_URL}/api/v2/facilities`, {
      headers: {
        'Authorization': `Bearer ${JWT_TOKEN}`,
        'X-API-Key': API_KEY
      }
    });
    const facilitiesData = await facilitiesResponse.json();
    const facilitiesMap = new Map(
      facilitiesData.facilities.map(f => [f.facilityId, f.name])
    );

    // 理事会情報取得
    const boardMeeting = await prisma.boardMeeting.findUnique({
      where: { id: data.boardMeetingId }
    });

    // 決定事項作成
    const decision = await prisma.boardDecision.create({
      data: {
        boardMeetingId: data.boardMeetingId,
        meetingDate: boardMeeting!.meetingDate,
        title: data.title,
        category: data.category,
        description: data.description,
        decision: data.decision,
        implementationDeadline: data.implementationDeadline,
        responsibleDept: data.responsibleDept,
        affectedFacilities: data.affectedFacilities,
        status: 'on_track',
        progress: 0
      }
    });

    // マイルストーン作成
    await prisma.boardDecisionMilestone.createMany({
      data: data.milestones.map((m, index) => ({
        boardDecisionId: decision.id,
        title: m.title,
        deadline: m.deadline,
        assignee: m.assignee,
        status: 'pending',
        sortOrder: index
      }))
    });

    // 施設別実施状況を初期化
    await prisma.boardDecisionFacilityImplementation.createMany({
      data: data.affectedFacilities.map(facilityId => ({
        boardDecisionId: decision.id,
        facilityId,
        facilityName: facilitiesMap.get(facilityId) || facilityId,
        status: 'not_started',
        progress: 0
      }))
    });

    return decision;
  }

  // マイルストーン更新 + 進捗自動再計算
  async updateMilestone(milestoneId: string, data: {
    status?: string;
    completedAt?: Date;
  }): Promise<void> {
    await prisma.boardDecisionMilestone.update({
      where: { id: milestoneId },
      data
    });

    // 親の決定事項の進捗を再計算
    const milestone = await prisma.boardDecisionMilestone.findUnique({
      where: { id: milestoneId },
      include: { boardDecision: true }
    });

    const allMilestones = await prisma.boardDecisionMilestone.findMany({
      where: { boardDecisionId: milestone!.boardDecisionId }
    });

    const completedCount = allMilestones.filter(m => m.status === 'completed').length;
    const progress = Math.round((completedCount / allMilestones.length) * 100);
    const status = this.calculateStatus(allMilestones);

    await prisma.boardDecision.update({
      where: { id: milestone!.boardDecisionId },
      data: { progress, status, lastUpdate: new Date() }
    });
  }

  // ステータス自動判定ロジック
  private calculateStatus(milestones: BoardDecisionMilestone[]): string {
    const now = new Date();

    const completedCount = milestones.filter(m => m.status === 'completed').length;
    if (completedCount === milestones.length) {
      return 'completed';
    }

    const hasDelayed = milestones.some(m =>
      m.status !== 'completed' && m.deadline < now
    );
    if (hasDelayed) {
      return 'delayed';
    }

    const hasAtRisk = milestones.some(m => {
      const daysToDeadline = Math.floor(
        (m.deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );
      return m.status !== 'completed' && daysToDeadline > 0 && daysToDeadline <= 7;
    });
    if (hasAtRisk) {
      return 'at_risk';
    }

    return 'on_track';
  }

  // 施設別実施状況更新 + 全体進捗再計算
  async updateFacilityImplementation(
    decisionId: string,
    facilityId: string,
    data: { status?: string; progress?: number; note?: string; }
  ): Promise<void> {
    await prisma.boardDecisionFacilityImplementation.update({
      where: {
        boardDecisionId_facilityId: { boardDecisionId: decisionId, facilityId }
      },
      data
    });

    // 全施設の平均進捗率を再計算
    const implementations = await prisma.boardDecisionFacilityImplementation.findMany({
      where: { boardDecisionId: decisionId }
    });
    const totalProgress = implementations.reduce((sum, impl) => sum + impl.progress, 0);
    const averageProgress = Math.round(totalProgress / implementations.length);

    await prisma.boardDecision.update({
      where: { id: decisionId },
      data: { progress: averageProgress, lastUpdate: new Date() }
    });
  }
}
```

**実装期間**: 3日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク3: API実装（5エンドポイント）

```typescript
// VoiceDrive: API実装

// 1. GET /api/board-decisions - 決定事項一覧取得
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const status = searchParams.get('status') || 'all';
  const category = searchParams.get('category');

  const where: any = {};
  if (status !== 'all') where.status = status;
  if (category) where.category = category;

  const decisions = await prisma.boardDecision.findMany({
    where,
    include: {
      milestones: { orderBy: { sortOrder: 'asc' } },
      facilityImplementations: true,
      boardMeeting: true
    },
    orderBy: { implementationDeadline: 'asc' }
  });

  const summary = {
    completed: decisions.filter(d => d.status === 'completed').length,
    on_track: decisions.filter(d => d.status === 'on_track').length,
    at_risk: decisions.filter(d => d.status === 'at_risk').length,
    delayed: decisions.filter(d => d.status === 'delayed').length
  };

  return NextResponse.json({ decisions, summary });
}

// 2. GET /api/board-decisions/:id/facility-implementations - 施設別実施状況取得
// 3. PUT /api/board-decisions/:id/milestones/:milestoneId - マイルストーン更新
// 4. PUT /api/board-decisions/:id/facility-implementations/:facilityId - 施設別実施状況更新
// 5. POST /api/board-decisions - 決定事項作成
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: バッチ処理実装（2つ）

```typescript
// VoiceDrive: バッチ処理

// 1. 施設名キャッシュ更新バッチ（毎日午前2時実行）
async function updateFacilityNameCache() {
  const response = await fetch(`${MEDICAL_SYSTEM_URL}/api/v2/facilities`, {
    headers: {
      'Authorization': `Bearer ${JWT_TOKEN}`,
      'X-API-Key': API_KEY
    }
  });

  if (!response.ok) {
    console.error('[Batch] Failed to fetch facilities from medical system');
    return;
  }

  const facilitiesData = await response.json();
  const facilitiesMap = new Map(
    facilitiesData.facilities.map(f => [f.facilityId, f.name])
  );

  const implementations = await prisma.boardDecisionFacilityImplementation.findMany();

  for (const impl of implementations) {
    const latestFacilityName = facilitiesMap.get(impl.facilityId);
    if (latestFacilityName && latestFacilityName !== impl.facilityName) {
      await prisma.boardDecisionFacilityImplementation.update({
        where: { id: impl.id },
        data: { facilityName: latestFacilityName }
      });
    }
  }
}

// 2. 遅延アラート通知バッチ（毎日午前9時実行）
async function sendDelayedAlerts() {
  const now = new Date();

  const alertDecisions = await prisma.boardDecision.findMany({
    where: { status: { in: ['delayed', 'at_risk'] } },
    include: { milestones: true, boardMeeting: true }
  });

  for (const decision of alertDecisions) {
    const delayedMilestones = decision.milestones.filter(m =>
      m.status !== 'completed' && m.deadline < now
    );

    if (delayedMilestones.length > 0) {
      // Level 18（理事長）に通知
      await prisma.notification.create({
        data: {
          userId: 'LEVEL18_USER_ID',
          category: 'board_decision_alert',
          title: '理事会決定事項の実施遅延',
          message: `「${decision.title}」の実施が遅延しています。${delayedMilestones.length}件のマイルストーンが期限切れです。`,
          link: '/board-decision-follow',
          priority: 'high',
          isRead: false
        }
      });
    }
  }
}
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟢 LOW（Phase 2で実装）

---

#### タスク5: フロントエンド実装

```typescript
// VoiceDrive: カスタムフック・コンポーネント

// 1. useBoardDecisions カスタムフック
const useBoardDecisions = (filter?: { status?: string; category?: string }) => {
  const queryString = new URLSearchParams(filter as any).toString();
  const { data, error, mutate } = useSWR(
    `/api/board-decisions?${queryString}`,
    fetcher,
    { refreshInterval: 60000, revalidateOnFocus: true }
  );

  const updateMilestone = async (decisionId: string, milestoneId: string, status: string) => {
    await fetch(`/api/board-decisions/${decisionId}/milestones/${milestoneId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status,
        completedAt: status === 'completed' ? new Date().toISOString() : null,
        updatedAt: new Date().toISOString()  // 楽観的ロック用
      })
    });
    mutate();
  };

  return {
    decisions: data?.decisions || [],
    summary: data?.summary || {},
    isLoading: !error && !data,
    isError: error,
    updateMilestone,
    refresh: mutate
  };
};

// 2. FacilityImplementationProgress コンポーネント
const FacilityImplementationProgress = ({ implementation }) => {
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return 'bg-green-500';
      case 'in_progress': return 'bg-blue-500';
      case 'not_started': return 'bg-gray-300';
    }
  };

  return (
    <div className="flex items-center gap-4">
      <div className="flex-1">
        <div className="flex justify-between text-sm mb-1">
          <span>{implementation.facilityName}</span>
          <span className="text-gray-600">{implementation.progress}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className={`h-2 rounded-full transition-all duration-300 ${getStatusColor(implementation.status)}`}
            style={{ width: `${implementation.progress}%` }}
          />
        </div>
      </div>
    </div>
  );
};
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### VoiceDrive実装スケジュール（BoardDecisionFollow）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: データベース構築（3テーブル） | 2日 | 🟡 MEDIUM | BoardAgendaReview後に実装 |
| **タスク2**: BoardDecisionFollowService | 3日 | 🟡 MEDIUM | 進捗自動計算・ステータス判定 |
| **タスク3**: API実装（5エンドポイント） | 2日 | 🟡 MEDIUM | Level 18権限チェック |
| **タスク4**: バッチ処理実装 | 1日 | 🟢 LOW | 施設名キャッシュ・遅延アラート |
| **タスク5**: フロントエンド実装 | 2日 | 🟡 MEDIUM | カスタムフック + プログレスバー |

**合計**: 10日（共通DB構築後に実施、BoardAgendaReview実装後）

**テスト要件**:
- ユニットテスト: 20ケース以上（進捗計算、ステータス判定）
- API統合テスト: 15ケース以上
- エンドツーエンドテスト: 1ケース（決定事項作成→マイルストーン更新→進捗確認）

**医療システムAPIの利用**:
- GET /api/v2/facilities（施設マスタ取得）- 決定事項作成時、日次キャッシュ更新時
- GET /api/v2/departments（部門マスタ取得）- 決定事項作成時

**関連ドキュメント**:
- [board-decision-follow_医療システム確認結果_20251011.md](../mcp-shared/docs/board-decision-follow_医療システム確認結果_20251011.md)
- [board-decision-follow_DB要件分析_20251011.md](../mcp-shared/docs/board-decision-follow_DB要件分析_20251011.md)
- 医療システム既存API（facilities, departments）

---

### 6.3.9 ProjectTracking VoiceDrive側実装タスク

**概要**: プロジェクト追跡ページ実装（ユーザーの投稿・投票・参加プロジェクト一覧）

**医療システムAPI依存**: なし（VoiceDrive内部データのみ使用）

**実装完了期限**: BoardDecisionFollow実装後 + 4日

**関連ドキュメント**:
- [project-tracking_医療システム確認結果_20251011.md](../mcp-shared/docs/project-tracking_医療システム確認結果_20251011.md)

---

#### タスク1: 複合インデックス追加（パフォーマンス最適化）

**実装期間**: 1日
**優先度**: 🔴 HIGH（パフォーマンスに直接影響）

**実装内容**:

既存のPost/Voteテーブルに複合インデックスを追加し、クエリパフォーマンスを10-50倍向上させる。

##### マイグレーション1: Post複合インデックス
```prisma
// prisma/schema.prisma

model Post {
  id          String   @id @default(cuid())
  authorId    String
  type        String   // 'project', 'discussion', etc.
  title       String
  description String?
  status      String   // 'active', 'completed', 'archived'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  votes    Vote[]
  comments Comment[]

  @@index([authorId, type, createdAt])  // 新規追加
}
```

**SQLマイグレーション**:
```sql
-- Migration: 20251011_add_post_author_type_created_index

CREATE INDEX "Post_authorId_type_createdAt_idx"
ON "Post"("authorId", "type", "createdAt" DESC);

-- 実行時間: 約5-30秒（Postテーブルサイズに依存）
-- ディスク使用量増加: Postレコード数 × 約50バイト
```

##### マイグレーション2: Vote複合インデックス
```prisma
// prisma/schema.prisma

model Vote {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  score     Int      @default(1)  // 1-10
  timestamp DateTime @default(now())

  post Post @relation(fields: [postId], references: [id])

  @@unique([userId, postId])
  @@index([userId, timestamp])  // 新規追加
}
```

**SQLマイグレーション**:
```sql
-- Migration: 20251011_add_vote_user_timestamp_index

CREATE INDEX "Vote_userId_timestamp_idx"
ON "Vote"("userId", "timestamp" DESC);

-- 実行時間: 約3-20秒（Voteテーブルサイズに依存）
-- ディスク使用量増加: Voteレコード数 × 約50バイト
```

**マイグレーション実行**:
```bash
# インデックス追加
npx prisma migrate dev --name add_project_tracking_indexes

# 本番環境適用
npx prisma migrate deploy
```

**検証**:
```sql
-- インデックス使用確認
EXPLAIN ANALYZE
SELECT * FROM "Post"
WHERE "authorId" = 'user-001'
  AND "type" = 'project'
ORDER BY "createdAt" DESC
LIMIT 10;

-- 結果に"Index Scan using Post_authorId_type_createdAt_idx"が含まれることを確認
```

---

#### タスク2: ProjectTrackingService実装

**実装期間**: 2日
**優先度**: 🔴 HIGH

**実装内容**:

プロジェクト追跡データ取得のためのサービス層を実装。

```typescript
// src/services/ProjectTrackingService.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ProjectTrackingService {
  /**
   * ユーザーが提案したプロジェクト一覧取得
   */
  async getMyProjects(userId: string, options: {
    limit?: number;
    offset?: number;
    status?: 'active' | 'completed' | 'archived';
  }) {
    const { limit = 10, offset = 0, status } = options;

    const where: any = {
      authorId: userId,
      type: 'project'
    };

    if (status) {
      where.status = status;
    }

    const [posts, totalCount] = await Promise.all([
      prisma.post.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: offset,
        take: limit,
        include: {
          _count: {
            select: {
              votes: true,
              comments: true
            }
          }
        }
      }),
      prisma.post.count({ where })
    ]);

    return {
      projects: posts.map(post => ({
        id: post.id,
        title: post.title,
        description: post.description,
        status: post.status,
        createdAt: post.createdAt,
        votesCount: post._count.votes,
        commentsCount: post._count.comments
      })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーが投票したプロジェクト一覧取得
   */
  async getVotedProjects(userId: string, options: {
    limit?: number;
    offset?: number;
  }) {
    const { limit = 10, offset = 0 } = options;

    const [votes, totalCount] = await Promise.all([
      prisma.vote.findMany({
        where: { userId },
        orderBy: { timestamp: 'desc' },
        skip: offset,
        take: limit,
        include: {
          post: {
            include: {
              _count: {
                select: {
                  votes: true,
                  comments: true
                }
              }
            }
          }
        }
      }),
      prisma.vote.count({ where: { userId } })
    ]);

    return {
      projects: votes
        .filter(vote => vote.post?.type === 'project')
        .map(vote => ({
          id: vote.post.id,
          title: vote.post.title,
          description: vote.post.description,
          status: vote.post.status,
          votedAt: vote.timestamp,
          myScore: vote.score,
          totalVotesCount: vote.post._count.votes,
          commentsCount: vote.post._count.comments
        })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーがコメント参加したプロジェクト一覧取得
   */
  async getJoinedProjects(userId: string, options: {
    limit?: number;
    offset?: number;
  }) {
    const { limit = 10, offset = 0 } = options;

    // ユニークなpostIdを取得
    const uniquePostIds = await prisma.comment.groupBy({
      by: ['postId'],
      where: {
        authorId: userId,
        post: {
          type: 'project'
        }
      },
      _max: {
        createdAt: true
      },
      orderBy: {
        _max: {
          createdAt: 'desc'
        }
      },
      skip: offset,
      take: limit
    });

    const postIds = uniquePostIds.map(g => g.postId);

    const posts = await prisma.post.findMany({
      where: {
        id: { in: postIds }
      },
      include: {
        _count: {
          select: {
            votes: true,
            comments: true
          }
        }
      }
    });

    const totalCount = await prisma.comment.groupBy({
      by: ['postId'],
      where: {
        authorId: userId,
        post: { type: 'project' }
      }
    }).then(results => results.length);

    return {
      projects: posts.map(post => ({
        id: post.id,
        title: post.title,
        description: post.description,
        status: post.status,
        votesCount: post._count.votes,
        commentsCount: post._count.comments
      })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーのプロジェクトアクティビティ統計取得
   */
  async getProjectStats(userId: string) {
    const [
      myPostsCount,
      votedPostsCount,
      commentedProjectsCount,
      achievedCount
    ] = await Promise.all([
      prisma.post.count({
        where: {
          authorId: userId,
          type: 'project'
        }
      }),
      prisma.vote.count({
        where: {
          userId,
          post: { type: 'project' }
        }
      }),
      prisma.comment.groupBy({
        by: ['postId'],
        where: {
          authorId: userId,
          post: { type: 'project' }
        }
      }).then(results => results.length),
      prisma.post.count({
        where: {
          authorId: userId,
          type: 'project',
          status: 'completed'
        }
      })
    ]);

    return {
      myPostsCount,
      votedPostsCount,
      commentedProjectsCount,
      achievedCount
    };
  }
}
```

**テスト**:
```typescript
// tests/unit/ProjectTrackingService.test.ts

describe('ProjectTrackingService', () => {
  it('getMyProjects - 正常系', async () => {
    const result = await service.getMyProjects('user-001', { limit: 10, offset: 0 });
    expect(result.projects).toBeInstanceOf(Array);
    expect(result.pagination.total).toBeGreaterThanOrEqual(0);
  });

  it('getVotedProjects - 投票順でソート', async () => {
    const result = await service.getVotedProjects('user-001', { limit: 10, offset: 0 });
    expect(result.projects[0].votedAt >= result.projects[1].votedAt).toBe(true);
  });

  it('getProjectStats - 統計取得', async () => {
    const stats = await service.getProjectStats('user-001');
    expect(stats).toHaveProperty('myPostsCount');
    expect(stats).toHaveProperty('votedPostsCount');
    expect(stats).toHaveProperty('commentedProjectsCount');
    expect(stats).toHaveProperty('achievedCount');
  });
});
```

---

#### タスク3: API実装（4エンドポイント）

**実装期間**: 1日
**優先度**: 🔴 HIGH

**実装内容**:

ProjectTracking用の4つのAPIエンドポイントを実装。

##### API 1: 提案したプロジェクト一覧
```typescript
// src/app/api/project-tracking/my-projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);
    const status = searchParams.get('status') as 'active' | 'completed' | 'archived' | undefined;

    if (limit < 1 || limit > 100) {
      return NextResponse.json(
        { error: { code: 'INVALID_PARAMETER', message: 'limit must be between 1-100' } },
        { status: 400 }
      );
    }

    const result = await service.getMyProjects(user.id, { limit, offset, status });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/my-projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch my projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 2: 投票したプロジェクト一覧
```typescript
// src/app/api/project-tracking/voted-projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    const result = await service.getVotedProjects(user.id, { limit, offset });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/voted-projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch voted projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 3: 参加したプロジェクト一覧
```typescript
// src/app/api/project-tracking/joined-projects/route.ts
// （API 2と同様の構造、service.getJoinedProjectsを呼び出し）
```

##### API 4: プロジェクト統計
```typescript
// src/app/api/project-tracking/stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const stats = await service.getProjectStats(user.id);

    return NextResponse.json({
      data: stats,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/stats error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch project stats',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

**APIテスト**:
```bash
# 提案したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/my-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 投票したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/voted-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 参加したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/joined-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 統計取得
curl -X GET "http://localhost:3000/api/project-tracking/stats" \
  -H "Authorization: Bearer $TOKEN"
```

---

#### VoiceDrive実装スケジュール（ProjectTracking）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: 複合インデックス追加 | 1日 | 🔴 HIGH | BoardDecisionFollow後に実装、パフォーマンス必須 |
| **タスク2**: ProjectTrackingService | 2日 | 🔴 HIGH | 4メソッド実装、Promise.all並列化 |
| **タスク3**: API実装（4エンドポイント） | 1日 | 🔴 HIGH | 認証必須、エラーハンドリング |

**合計**: 4日（共通DB構築後に実施、BoardDecisionFollow実装後）

**テスト要件**:
- ユニットテスト: 10ケース以上（サービス層のみ）
- API統合テスト: 12ケース以上（4エンドポイント × 3ケース）
- パフォーマンステスト: 2ケース（複合インデックス効果検証）
- E2Eテスト: 1ケース（タブ切り替え動作確認）

**医療システムAPIの利用**: なし（VoiceDrive内部データのみ使用）

**特記事項**:
- ✅ 医療システムとの連携不要（最もシンプルな実装）
- ✅ 新しいテーブル追加不要（既存Post/Vote/Commentテーブルのみ使用）
- ⚠️ 複合インデックス必須（データ増加時のパフォーマンス劣化防止）
- 📊 スコア計算はフロントエンドで実施（DBに保存しない）

---

### 6.3.10 ProgressDashboard VoiceDrive側実装タスク

**概要**: 進捗ダッシュボード実装（複数部署・施設全体のプロジェクト進捗を俯瞰的に管理）

**医療システムAPI依存**: 既存APIのみ使用（facilities/departments/employees）

**実装完了期限**: ProjectTracking実装後 + 9日

**関連ドキュメント**:
- [progress-dashboard_医療システム確認結果_20251011.md](../mcp-shared/docs/progress-dashboard_医療システム確認結果_20251011.md)

---

#### タスク1: データベース構築（2テーブル追加 + Post拡張）

**実装期間**: 1.5日
**優先度**: 🔴 HIGH（コア機能の基盤）

**実装内容**:

既存Postテーブルにプロジェクト管理フィールドを追加し、マイルストーン・チームメンバー管理用の新規テーブルを作成。

##### Postテーブル拡張

```prisma
model Post {
  // ... 既存フィールド

  // ProgressDashboard統合実装（2025-10-11）
  projectDueDate      DateTime? @map("project_due_date")      // プロジェクト期限
  projectLevel        String?   @map("project_level")         // 'team' | 'department' | 'facility' | 'organization'
  projectProgress     Int?      @default(0) @map("project_progress")  // 進捗率（0-100）

  // Relations
  milestones          ProjectMilestone[]   @relation("ProjectMilestones")
  teamMembers         ProjectTeamMember[]  @relation("ProjectTeamMembers")

  @@index([type, status, createdAt])  // プロジェクト一覧取得用
  @@index([projectDueDate])            // 期限ソート・遅延判定用（新規）
  @@index([projectLevel])              // レベル別フィルタリング用（新規）
}
```

##### ProjectMilestoneテーブル（新規）

```prisma
model ProjectMilestone {
  id                String    @id @default(cuid())
  projectId         String    @map("project_id")
  title             String
  description       String?   @db.Text
  dueDate           DateTime  @map("due_date")
  completedAt       DateTime? @map("completed_at")
  completedBy       String?   @map("completed_by")
  status            String    @default("pending") // 'pending' | 'in_progress' | 'completed' | 'cancelled'
  order             Int       @default(0)
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  project           Post      @relation("ProjectMilestones", fields: [projectId], references: [id], onDelete: Cascade)
  completedByUser   User?     @relation("MilestoneCompletedBy", fields: [completedBy], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([status])
  @@index([dueDate])
  @@map("project_milestones")
}
```

##### ProjectTeamMemberテーブル（新規）

```prisma
model ProjectTeamMember {
  id                String    @id @default(cuid())
  projectId         String    @map("project_id")
  userId            String    @map("user_id")
  role              String    @default("member") // 'leader' | 'sub_leader' | 'member' | 'observer'
  joinedAt          DateTime  @default(now()) @map("joined_at")
  leftAt            DateTime? @map("left_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  project           Post      @relation("ProjectTeamMembers", fields: [projectId], references: [id], onDelete: Cascade)
  user              User      @relation("ProjectMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([role])
  @@map("project_team_members")
}
```

##### Userテーブル拡張

```prisma
model User {
  // ... 既存フィールド

  // ProgressDashboard統合実装（2025-10-11）
  projectMemberships      ProjectTeamMember[]   @relation("ProjectMemberships")
  completedMilestones     ProjectMilestone[]    @relation("MilestoneCompletedBy")
}
```

**マイグレーション実行**:
```bash
# スキーマ更新
npx prisma migrate dev --name add_progress_dashboard_tables

# 既存プロジェクトデータ移行
UPDATE "Post"
SET
  "project_due_date" = "createdAt" + INTERVAL '3 months',
  "project_level" = 'team',
  "project_progress" = 0
WHERE "type" = 'project' AND "project_due_date" IS NULL;
```

---

#### タスク2: ProgressDashboardService実装

**実装期間**: 2日
**優先度**: 🔴 HIGH

**実装内容**:

プロジェクト一覧取得・統計計算・マイルストーン管理のサービス層を実装。

```typescript
// src/services/ProgressDashboardService.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ProgressDashboardService {
  /**
   * アクセス可能なプロジェクト一覧取得
   */
  async getAccessibleProjects(userId: string, options: {
    filter?: 'all' | 'active' | 'completed' | 'delayed';
    facilityId?: string;
    departmentId?: string;
    limit?: number;
    offset?: number;
  }) {
    const { filter = 'all', limit = 20, offset = 0 } = options;

    // 1. ユーザー権限取得
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, level: true, facilityId: true, departmentId: true }
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.level < 10) {
      throw new Error('Level 10+ required for ProgressDashboard');
    }

    // 2. WHERE条件構築
    const where: any = { type: 'project' };

    // 2.1 ステータスフィルター
    if (filter === 'active') {
      where.status = 'active';
    } else if (filter === 'completed') {
      where.status = 'completed';
    }

    // 2.2 権限ベースフィルタリング
    if (user.level < 13) {
      // Level 10-12: 自施設のみ
      where.author = {
        facilityId: options.facilityId || user.facilityId
      };

      if (user.level === 10) {
        // Level 10 (部長): 自部門のみ
        where.author = {
          ...where.author,
          departmentId: options.departmentId || user.departmentId
        };
      }
    }
    // Level 13+: 全施設アクセス可能（フィルタなし）

    // 3. プロジェクト取得
    const projects = await prisma.post.findMany({
      where,
      include: {
        author: {
          select: {
            id: true,
            name: true,
            facilityId: true,
            departmentId: true
          }
        },
        milestones: {
          select: {
            id: true,
            status: true
          }
        },
        teamMembers: {
          where: { leftAt: null },
          select: {
            id: true,
            userId: true,
            role: true
          }
        },
        _count: {
          select: {
            milestones: true,
            teamMembers: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: limit
    });

    // 4. 総件数取得
    const totalCount = await prisma.post.count({ where });

    // 5. データ加工（遅延判定・進捗計算）
    const now = new Date();
    const result = projects.map(project => {
      const completedMilestones = project.milestones.filter(m => m.status === 'completed').length;
      const totalMilestones = project.milestones.length;

      // 進捗計算
      const progress = totalMilestones > 0
        ? Math.round((completedMilestones / totalMilestones) * 100)
        : project.projectProgress || 0;

      // 遅延判定
      const isDelayed = project.projectDueDate &&
                       project.projectDueDate < now &&
                       project.status !== 'completed';

      return {
        id: project.id,
        title: project.title || '無題のプロジェクト',
        description: project.content,
        status: project.status,
        progress,
        teamSize: project._count.teamMembers,
        completedMilestones,
        totalMilestones,
        dueDate: project.projectDueDate?.toISOString(),
        isDelayed,
        level: project.projectLevel,
        createdAt: project.createdAt.toISOString()
      };
    });

    // 6. 遅延フィルタリング（必要な場合）
    const filteredResult = filter === 'delayed'
      ? result.filter(p => p.isDelayed)
      : result;

    return {
      projects: filteredResult,
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * プロジェクト統計取得
   */
  async getProjectStats(userId: string, options: {
    facilityId?: string;
    departmentId?: string;
  }) {
    // ユーザー権限取得
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, level: true, facilityId: true, departmentId: true }
    });

    if (!user || user.level < 10) {
      throw new Error('Insufficient permissions');
    }

    // WHERE条件構築（getAccessibleProjectsと同じロジック）
    const where: any = { type: 'project' };

    if (user.level < 13) {
      where.author = {
        facilityId: options.facilityId || user.facilityId
      };
      if (user.level === 10) {
        where.author = {
          ...where.author,
          departmentId: options.departmentId || user.departmentId
        };
      }
    }

    // 並列クエリで統計取得
    const [total, active, completed, allProjects] = await Promise.all([
      prisma.post.count({ where }),
      prisma.post.count({ where: { ...where, status: 'active' } }),
      prisma.post.count({ where: { ...where, status: 'completed' } }),
      prisma.post.findMany({
        where,
        include: {
          milestones: {
            select: { status: true }
          }
        }
      })
    ]);

    // 遅延判定
    const now = new Date();
    const delayed = allProjects.filter(p =>
      p.projectDueDate && p.projectDueDate < now && p.status !== 'completed'
    ).length;

    // 平均進捗計算
    const avgProgress = allProjects.length > 0
      ? Math.round(
          allProjects.reduce((sum, p) => {
            const completedMilestones = p.milestones.filter(m => m.status === 'completed').length;
            const totalMilestones = p.milestones.length;
            const progress = totalMilestones > 0
              ? (completedMilestones / totalMilestones) * 100
              : p.projectProgress || 0;
            return sum + progress;
          }, 0) / allProjects.length
        )
      : 0;

    return {
      total,
      active,
      completed,
      delayed,
      avgProgress
    };
  }
}
```

**テスト**:
```typescript
// tests/unit/ProgressDashboardService.test.ts

describe('ProgressDashboardService', () => {
  it('getAccessibleProjects - Level 10は自部門のみアクセス可能', async () => {
    const result = await service.getAccessibleProjects('level10-user-001', {
      filter: 'all',
      limit: 10
    });

    // すべてのプロジェクトが自部門のもの
    result.projects.forEach(project => {
      expect(project.author.departmentId).toBe('dept-A');
    });
  });

  it('getProjectStats - 統計計算が正しい', async () => {
    const stats = await service.getProjectStats('level10-user-001', {});

    expect(stats).toHaveProperty('total');
    expect(stats).toHaveProperty('active');
    expect(stats).toHaveProperty('completed');
    expect(stats).toHaveProperty('delayed');
    expect(stats).toHaveProperty('avgProgress');
    expect(stats.avgProgress).toBeGreaterThanOrEqual(0);
    expect(stats.avgProgress).toBeLessThanOrEqual(100);
  });
});
```

---

#### タスク3: API実装（3エンドポイント）

**実装期間**: 1.5日
**優先度**: 🔴 HIGH

**実装内容**:

ProgressDashboard用の3つのAPIエンドポイントを実装。

##### API 1: プロジェクト一覧取得

```typescript
// src/app/api/progress-dashboard/projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProgressDashboardService } from '@/services/ProgressDashboardService';
import { authenticateUser } from '@/lib/auth';

const service = new ProgressDashboardService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    // Level 10+チェック
    if (user.level < 10) {
      return NextResponse.json(
        {
          error: {
            code: 'FORBIDDEN',
            message: 'このページは部長以上のみアクセス可能です',
            details: `User level: ${user.level}, Required: 10+`
          }
        },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const filter = searchParams.get('filter') as 'all' | 'active' | 'completed' | 'delayed' | undefined;
    const facilityId = searchParams.get('facilityId') || undefined;
    const departmentId = searchParams.get('departmentId') || undefined;
    const limit = parseInt(searchParams.get('limit') || '20', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    const result = await service.getAccessibleProjects(user.id, {
      filter,
      facilityId,
      departmentId,
      limit,
      offset
    });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/progress-dashboard/projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 2: 統計サマリー取得

```typescript
// src/app/api/progress-dashboard/stats/route.ts
// （API 1と同様の構造、service.getProjectStatsを呼び出し）
```

##### API 3: マイルストーン一覧取得

```typescript
// src/app/api/progress-dashboard/projects/[projectId]/milestones/route.ts
// （プロジェクトIDからマイルストーン一覧を取得）
```

**APIテスト**:
```bash
# プロジェクト一覧取得
curl -X GET "http://localhost:3000/api/progress-dashboard/projects?filter=all&limit=10" \
  -H "Authorization: Bearer $LEVEL10_TOKEN"

# 統計サマリー取得
curl -X GET "http://localhost:3000/api/progress-dashboard/stats" \
  -H "Authorization: Bearer $LEVEL10_TOKEN"
```

---

#### タスク4: フロントエンド実装（オプション）

**実装期間**: 2日
**優先度**: 🟡 MEDIUM（VoiceDrive側で実装済みの可能性）

**実装内容**:

useProgressDashboardフックとProgressDashboardページコンポーネント。

```typescript
// src/hooks/useProgressDashboard.ts

import useSWR from 'swr';

export function useProgressDashboard(
  filter: 'all' | 'active' | 'completed' | 'delayed',
  options?: {
    facilityId?: string;
    departmentId?: string;
  }
) {
  const queryParams = new URLSearchParams({
    filter,
    ...(options?.facilityId && { facilityId: options.facilityId }),
    ...(options?.departmentId && { departmentId: options.departmentId })
  });

  const { data: projectsData, error: projectsError, isLoading: projectsLoading } = useSWR(
    `/api/progress-dashboard/projects?${queryParams.toString()}`
  );

  const { data: statsData, error: statsError, isLoading: statsLoading } = useSWR(
    `/api/progress-dashboard/stats?${queryParams.toString()}`,
    { refreshInterval: 60000 }
  );

  return {
    projects: projectsData?.data || [],
    pagination: projectsData?.pagination,
    stats: statsData?.data,
    isLoading: projectsLoading || statsLoading,
    error: projectsError || statsError
  };
}
```

---

#### VoiceDrive実装スケジュール（ProgressDashboard）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: データベース構築 | 1.5日 | 🔴 HIGH | ProjectTracking後、2新規テーブル + Post拡張 |
| **タスク2**: ProgressDashboardService | 2日 | 🔴 HIGH | 権限ベースフィルタリング必須 |
| **タスク3**: API実装（3エンドポイント） | 1.5日 | 🔴 HIGH | Level 10+チェック、エラーハンドリング |
| **タスク4**: フロントエンド実装 | 2日 | 🟡 MEDIUM | オプション（既存実装確認） |
| **テスト・デバッグ** | 2日 | 🔴 HIGH | 権限テスト、パフォーマンステスト |

**合計**: 9日（共通DB構築後に実施、ProjectTracking実装後）

**テスト要件**:
- ユニットテスト: 15ケース以上（遅延判定、進捗計算、権限チェック）
- API統合テスト: 12ケース以上（3エンドポイント × 4ケース）
- 権限テスト: Level 10/13での動作確認（必須）
- パフォーマンステスト: 1,000プロジェクトでの一覧取得速度（< 500ms）

**医療システムAPIの利用**: 既存APIのみ使用
- GET /api/v2/facilities - 施設マスター取得
- GET /api/v2/departments - 部門マスター取得
- GET /api/v2/employees/{id} - 職員情報取得

**特記事項**:
- ⚠️ Level 10（部長）は自部門のみアクセス可能
- ⚠️ Level 13+（理事）は全施設アクセス可能
- ✅ 進捗計算はマイルストーン完了率から自動算出
- 📊 遅延判定は期限日時 < 現在日時 && status !== 'completed'

---

### 6.4 Strategic HR Plan API統合テスト

**前提条件**:
- ⏳ Phase 1実装予定（2025年10月21日〜11月1日）
- ⏳ 単体テスト予定（モックデータ）
- ✅ 実装方針確定済み（MED-CONF-2025-1010-013）
- ✅ VoiceDrive回答書受領済み（VD-A-2025-1010-012）

#### 6.4.1 Phase分割戦略

**Phase 1: 戦略的人事計画タブ（推定6日、10/21-11/1）**
- DB: 3テーブル（StrategicHRGoal, StrategicInitiative, HRStrategyRoadmap）
- API: 4エンドポイント
- スコープ外: パフォーマンス分析、組織健全性指標、退職理由分析

**Phase 2: 組織開発・パフォーマンス分析（推定6.5日、12月中旬〜1月上旬）**
- DB: 5テーブル（OrganizationHealthMetrics, PerformanceAnalytics, ImprovementProposal等）
- API: 5エンドポイント
- VoiceDrive活動データ統合開始

**Phase 3: 退職管理・高度分析（推定3.5日、2026年1月下旬〜2月上旬）**
- DB: 5テーブル（RetirementProcess, InfluenceAnalysis等）
- API: 3エンドポイント
- 影響力分析の実データ表示

#### 6.4.2 環境変数設定

```bash
# .env.productionに追加
STRATEGIC_HR_API_KEY=[openssl rand -hex 32で生成したAPI Key]

# VoiceDrive側の設定確認（VoiceDriveチームに共有）
# MEDICAL_SYSTEM_STRATEGIC_HR_URL=https://medical.example.com/api/v2/strategic-hr
# MEDICAL_SYSTEM_STRATEGIC_HR_KEY=[上記のSTRATEGIC_HR_API_KEYと同じ値]
```

**API Key生成方法**:
```bash
# ランダムなAPI Keyを生成
openssl rand -hex 32

# 生成されたAPI Keyを.env.productionとVoiceDriveチームに共有
```

#### 6.4.3 Phase 1実データでAPI動作確認

```bash
# API-1: 戦略的人事目標取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024&facilityId=facility-001" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": {
#     "fiscalYear": 2024,
#     "facilityId": "facility-001",
#     "employeeSatisfactionTarget": 85.0,
#     "employeeSatisfactionCurrent": 82.3,
#     "turnoverRateTarget": 8.5,
#     "turnoverRateCurrent": 9.2,
#     "annualHiringTarget": 15,
#     "annualHiringCurrent": 12
#   },
#   "meta": {
#     "timestamp": "2025-10-21T12:00:00.000Z"
#   }
# }

# API-2: 戦略的イニシアチブ取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/initiatives?facilityId=facility-001&status=in_progress" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": [
#     {
#       "id": "init-001",
#       "name": "メンター制度導入",
#       "description": "新人看護師向けメンター制度の導入",
#       "category": "人材育成",
#       "progressPercent": 65.0,
#       "deadline": "2024-12-31",
#       "priority": "high",
#       "status": "in_progress"
#     }
#   ],
#   "meta": {
#     "total": 5,
#     "timestamp": "2025-10-21T12:00:00.000Z"
#   }
# }

# API-3: 人材戦略ロードマップ取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/roadmap?facilityId=facility-001" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# API-4: 退職統計取得テスト
curl -X GET "http://localhost:3000/api/v2/retirement/statistics?facilityId=facility-001&fiscalYear=2024" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 注意: Phase 1では基本統計のみ、Phase 3で詳細な退職理由分析を実装
```

#### 6.4.4 エラーハンドリングテスト

```bash
# 401 Unauthorized（API Key未提供）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"API Key is required"}}

# 401 Unauthorized（不正なAPI Key）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
  -H "X-API-Key: invalid-key"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"Invalid API Key"}}

# 403 Forbidden（権限不足）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}" \
  -H "X-User-Permission-Level: 10"
# 期待: {"error":{"code":"FORBIDDEN","message":"Level 16+ required"}}

# 429 Rate Limit超過テスト（100回超過でエラー）
for i in {1..105}; do
  curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
    -H "X-API-Key: ${STRATEGIC_HR_API_KEY}" \
    -H "X-Forwarded-For: 192.168.1.200"
done
# 101回目以降: {"error":{"code":"RATE_LIMIT_EXCEEDED","message":"Too many requests"}}
```

#### 6.4.5 VoiceDriveチームとの統合テスト

```bash
# VoiceDriveチームに以下を共有:
# - APIエンドポイントURL: https://medical.example.com/api/v2/strategic-hr
# - VoiceDrive用APIキー: [Slackで共有]
# - 実装方針確定書: mcp-shared/docs/strategic-hr-plan_実装方針確定書_20251010.md

# VoiceDriveチーム側での確認事項:
# 1. StrategicHRServiceでAPIを呼び出し（Phase 1: 4エンドポイント）
# 2. StrategicHRPageの戦略的人事計画タブが実データで表示
# 3. Level 16権限チェックが正常動作
# 4. 施設フィルタリング（Level 18用）が動作
```

#### 6.4.6 Phase 1統合テスト完了基準
- [ ] API-1（戦略的人事目標）が実データで正常動作
- [ ] API-2（戦略的イニシアチブ）が実データで正常動作
- [ ] API-3（人材戦略ロードマップ）が実データで正常動作
- [ ] API-4（退職統計）が実データで正常動作
- [ ] Rate Limitヘッダーが正常に返却される
- [ ] エラーレスポンスが仕様通り
- [ ] VoiceDrive StrategicHRPageの戦略的人事計画タブで表示確認
- [ ] Level 16権限チェック動作確認
- [ ] 施設フィルタリング動作確認（Level 18用）

**推定工数**: Phase 1統合テスト 2日間（DB構築後）

**関連ドキュメント**:
- 実装方針確定書: `mcp-shared/docs/strategic-hr-plan_実装方針確定書_20251010.md`
- VoiceDrive回答書: `mcp-shared/docs/strategic-hr-plan_VoiceDrive回答書_20251010.md`
- DB要件分析: `mcp-shared/docs/strategic-hr-plan_DB要件分析_20251010.md`
- テーブル設計承認依頼: `mcp-shared/docs/strategic-hr-plan_テーブル設計承認依頼_20251010.md`

**実装予定ファイル（Phase 1）**:
- `src/app/api/v2/strategic-hr/goals/route.ts` - 戦略的人事目標API
- `src/app/api/v2/strategic-hr/initiatives/route.ts` - 戦略的イニシアチブAPI
- `src/app/api/v2/strategic-hr/roadmap/route.ts` - 人材戦略ロードマップAPI
- `src/app/api/v2/retirement/statistics/route.ts` - 退職統計API
- テストファイル4件（Phase 1単体テスト）

#### 6.4.7 Phase 2/3統合テスト（将来実装）

**Phase 2統合テスト（12月中旬〜1月上旬予定）**:
- 組織健全性指標API統合テスト
- パフォーマンス分析API統合テスト
- 改善提案実績API統合テスト
- VoiceDrive活動データ統合テスト

**Phase 3統合テスト（2026年1月下旬〜2月上旬予定）**:
- 退職プロセスAPI統合テスト
- 退職理由分析API統合テスト
- 影響力分析API統合テスト

---

## 7. Step 6: 本番デプロイ準備

### 7.1 最終確認
```bash
# 全テストスイート実行
npm run test:all:production

# パフォーマンステスト
npm run test:performance
```

### 7.2 デプロイチェックリスト
- [ ] 全テスト合格（32/32）
- [ ] VoiceDrive連携確認済み
- [ ] バックアップ作成済み
- [ ] ロールバック手順確認済み
- [ ] 監視設定完了

---

## 8. Step 7: 本番デプロイ

### 8.1 デプロイコマンド
```bash
# ビルド
npm run build:production

# デプロイ
npm run deploy:production

# ヘルスチェック
npm run health:check
```

### 8.2 デプロイ後確認
```bash
# ログ監視
npm run logs:production

# メトリクス確認
npm run metrics:check
```

---

## 9. トラブルシューティング

### よくある問題と対処法

#### 問題1: 統括主任のレベルが6になっている
```javascript
// facility-position-mapping.tsの63行目を確認
{ positionName: '統括主任', baseLevel: 7, ... }  // 7であることを確認
```

#### 問題2: 兼任職員の権限が低い方で適用される
```javascript
// 権限取得ロジックを確認
const effectiveLevel = Math.max(position1Level, position2Level);
```

#### 問題3: エスポワール立神が認識されない
```bash
# 施設IDを確認
echo $DEFAULT_FACILITY_ID  # espoir-tategami であること
```

---

## 10. 連絡先

### 緊急時連絡先
- インフラチーム: [連絡先]
- VoiceDriveチーム: [連絡先]
- DB管理者: [連絡先]

### ドキュメント参照
- 作業完了報告書: `/docs/エスポワール立神統合_作業完了報告書_20250928.md`
- VoiceDrive連携仕様: `/docs/20250928_エスポワール立神統合連絡書.md`
- テスト結果: `/docs/統合テスト実施記録_20250928.md`

---

## 11. 作業完了基準

以下が全て完了したら作業完了とする:

1. ✅ DB接続確認
2. ✅ マスターデータ投入完了
3. ✅ 統合テスト全項目合格
4. ✅ VoiceDrive連携確認
   - [ ] Webhook疎通確認
   - [ ] データ同期テスト
   - [ ] OrganizationAnalytics API統合テスト
   - [ ] ExecutiveReports API統合テスト（2025年10月25日予定）
   - [ ] BoardPreparation VoiceDrive実装確認（タスク1-4）
   - [ ] Strategic HR Plan API統合テスト（Phase 1）
5. ✅ 本番環境デプロイ完了
6. ✅ 24時間の安定稼働確認

---

**重要**: 作業中に問題が発生した場合は、すぐに関係チームに連絡し、
ロールバック判断を仰ぐこと。

---

作成者: 医療職員管理システム開発チーム
作成日: 2025年9月28日
最終更新: 2025年10月11日（ProgressDashboard VoiceDrive実装タスク追加 - 6.3.10節）