# 共通DB構築後 作業再開指示書

作成日: 2025年9月28日
最終更新: 2025年10月21日（Phase 8: 承認・対応管理API実装 追加 - 6.8節）
対象: 医療職員管理システム開発チーム
前提: 共通DBの構築完了後に本書を参照

---

## 1. 作業再開前チェックリスト

### 環境確認
- [ ] 共通DB接続情報の受領
- [ ] VPNアクセス権限の確認
- [ ] 本番環境へのデプロイ権限
- [ ] VoiceDriveチームとの連携確認

### コードベース確認
- [ ] 最新のmainブランチをpull
- [ ] node_modules再インストール（`npm ci`）
- [ ] TypeScriptビルド確認（`npm run build`）

---

## 2. Step 1: 環境設定更新

### 2.1 本番環境設定ファイル作成
```bash
# .env.productionを作成
cp .env.example .env.production
```

### 2.2 環境変数設定
```env
# .env.production
DATABASE_URL=postgresql://[ユーザー名]:[パスワード]@[ホスト]:[ポート]/[データベース名]
FACILITY_DB_HOST=[共通DBホスト]
FACILITY_DB_PORT=5432
FACILITY_DB_NAME=[データベース名]
FACILITY_DB_USER=[ユーザー名]
FACILITY_DB_PASSWORD=[パスワード]

# 施設識別
DEFAULT_FACILITY_ID=espoir-tategami
MULTI_FACILITY_MODE=true

# Webhook設定（VoiceDrive連携用）
VOICEDRIVE_WEBHOOK_URL=[VoiceDriveチームから提供されるURL]
WEBHOOK_SECRET=[共有シークレットキー]
WEBHOOK_RETRY_COUNT=3
WEBHOOK_TIMEOUT=5000
```

---

## 3. Step 2: データベース接続確認

### 3.1 接続テスト実行
```bash
# DB接続テスト
npm run test:db:connection

# 期待される出力:
# ✅ データベース接続成功
# ✅ facilityマスターテーブル確認
# ✅ positionマスターテーブル確認
# ✅ staff_authorityテーブル確認
```

### 3.2 接続エラー時の対処
```bash
# ログ確認
tail -f logs/db-connection.log

# 一般的なエラー:
# - SSL証明書エラー → ssl: { rejectUnauthorized: false }を一時的に追加
# - タイムアウト → ファイアウォール設定確認
# - 認証エラー → 認証情報再確認
```

---

## 4. Step 3: マスターデータ投入

### 4.1 施設マスター登録
```sql
-- 実行するSQL（/sql/master-data/facilities.sql）
INSERT INTO facilities (facility_id, facility_name, facility_type, staff_count) VALUES
('obara-hospital', '医療法人 厚生会 小原病院', 'acute', 420),
('tategami-rehabilitation', '立神リハビリテーション温泉病院', 'rehabilitation', 180),
('espoir-tategami', '介護老人保健施設エスポワール立神', 'geriatric_health_facility', 150);
```

### 4.2 役職マスター登録
```bash
# マイグレーション実行
npm run db:migrate:production

# 確認
npm run db:verify:positions
```

### 4.3 エスポワール立神データ投入
```bash
# 33役職の一括登録
node scripts/import-espoir-positions.js

# 検証
node scripts/verify-espoir-data.js
```

---

## 5. Step 4: 統合テスト実施

### 5.1 Phase 3統合テスト
```bash
# 実環境での統合テスト
NODE_ENV=production node tests/integration/phase3-integration-test.js

# 確認項目:
# - 小原病院: 9役職
# - 立神リハビリ: 12役職（統括主任レベル7）
# - エスポワール立神: 33役職
```

### 5.2 エスポワール立神特化テスト
```bash
# Day 1-3統合テスト実行
npm run test:espoir:complete

# 個別実行
node tests/integration/run-integration-test.ts  # Day 1
node tests/integration/day2-approval-flow-test.ts  # Day 2
node tests/integration/day3-load-test.ts  # Day 3（作成要）
```

### 5.3 兼任職員権限テスト
```bash
# 特定職員のテスト
node tests/verify-dual-position.js --staff-id ESP_003
node tests/verify-dual-position.js --staff-id ESP_004
```

---

## 6. Step 5: VoiceDrive連携確認

### 6.1 Webhook疎通確認
```bash
# テスト送信
curl -X POST $VOICEDRIVE_WEBHOOK_URL \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Secret: $WEBHOOK_SECRET" \
  -d '{"test": true, "facility": "espoir-tategami"}'
```

### 6.2 データ同期テスト
```bash
# 同期テスト実行
node scripts/test-voicedrive-sync.js

# ログ確認
tail -f logs/voicedrive-sync.log
```

### 6.3 OrganizationAnalytics API統合テスト

**前提条件**:
- ✅ API実装完了（2025年10月10日）
- ✅ 単体テスト30件全て成功（モックデータ）
- ✅ API仕様書承認済み（VD-APPROVAL-2025-1010-001）
- ✅ 実装報告書作成済み（mcp-shared/docs/organization-analytics_API実装完了報告_20251010.md）

#### 6.3.1 環境変数設定
```bash
# .env.productionに追加
ORGANIZATION_ANALYTICS_API_KEY=[openssl rand -hex 32で生成したAPI Key]

# VoiceDrive側の設定確認（VoiceDriveチームに共有）
# MEDICAL_SYSTEM_API_URL=https://medical.example.com/api/v2
# MEDICAL_SYSTEM_API_KEY=[上記のORGANIZATION_ANALYTICS_API_KEYと同じ値]
```

**API Key生成方法**:
```bash
# ランダムなAPI Keyを生成
openssl rand -hex 32

# 生成されたAPI Keyを.env.productionとVoiceDriveチームに共有
```

#### 6.3.2 実データでAPI動作確認
```bash
# API-1: 部門マスタ取得テスト
curl -X GET "http://localhost:3000/api/v2/departments?facilityId=facility-001" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": [
#     {
#       "departmentId": "dept-001",
#       "departmentCode": "D001",
#       "departmentName": "内科",
#       "facilityId": "facility-001",
#       "facilityCode": "F001",
#       "facilityName": "小原病院",
#       "parentDepartmentId": null,
#       "level": 1,
#       "createdAt": "2024-01-01T00:00:00.000Z",
#       "updatedAt": "2024-01-01T00:00:00.000Z"
#     }
#   ],
#   "meta": {
#     "total": 9,
#     "timestamp": "2025-10-10T12:00:00.000Z"
#   }
# }

# API-2: 職員数取得テスト
curl -X GET "http://localhost:3000/api/v2/employees/count?facilityId=facility-001" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": {
#     "totalCount": 120,
#     "byDepartment": [
#       {
#         "departmentId": "dept-001",
#         "departmentCode": "D001",
#         "departmentName": "内科",
#         "count": 50
#       },
#       {
#         "departmentId": "dept-002",
#         "departmentCode": "D002",
#         "departmentName": "外科",
#         "count": 70
#       }
#     ]
#   },
#   "meta": {
#     "timestamp": "2025-10-10T12:00:00.000Z",
#     "filters": {
#       "facilityId": "facility-001",
#       "departmentId": null
#     }
#   }
# }

# 注意: Phase 1では雇用形態別カウント未対応
# 理由: employmentTypeフィールド未実装（Phase 2で対応予定）
```

#### 6.3.3 エラーハンドリングテスト
```bash
# 401 Unauthorized（API Key未提供）
curl -X GET "http://localhost:3000/api/v2/departments"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"API Key is required"}}

# 401 Unauthorized（不正なAPI Key）
curl -X GET "http://localhost:3000/api/v2/departments" \
  -H "X-API-Key: invalid-key"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"Invalid API Key"}}

# 400 Bad Request（Phase 1未対応パラメータ）
curl -X GET "http://localhost:3000/api/v2/departments?isActive=true" \
  -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}"
# 期待: {"error":{"code":"BAD_REQUEST","message":"Invalid query parameter","details":"isActive filter is not supported in Phase 1"}}

# 429 Rate Limit超過テスト（100回超過でエラー）
for i in {1..105}; do
  curl -X GET "http://localhost:3000/api/v2/departments" \
    -H "X-API-Key: ${ORGANIZATION_ANALYTICS_API_KEY}" \
    -H "X-Forwarded-For: 192.168.1.100"
done
# 101回目以降: {"error":{"code":"RATE_LIMIT_EXCEEDED","message":"Too many requests"}}
```

#### 6.3.4 VoiceDriveチームとの統合テスト
```bash
# VoiceDriveチームに以下を共有:
# - APIエンドポイントURL: https://medical.example.com/api/v2
# - VoiceDrive用APIキー: [Slackで共有]
# - API仕様書: mcp-shared/docs/organization-analytics_API仕様書_20251010.yaml

# VoiceDriveチーム側での確認事項:
# 1. OrganizationAnalyticsServiceでAPIを呼び出し
# 2. 組織健康度指標が正常に計算されるか確認
# 3. 部門別活性度が正常に表示されるか確認
```

#### 6.3.5 統合テスト完了基準
- [ ] API-1（部門マスタ）が実データで正常動作
- [ ] API-2（職員総数）が実データで正常動作
- [ ] Rate Limitヘッダーが正常に返却される
- [ ] エラーレスポンスが仕様通り
- [ ] VoiceDrive OrganizationAnalyticsページで表示確認

**推定工数**: 2日間（DB構築後）

**関連ドキュメント**:
- API仕様書: `mcp-shared/docs/organization-analytics_API仕様書_20251010.yaml`
- 承認書: `mcp-shared/docs/organization-analytics_API仕様書承認済み_20251010.md`
- 実装報告書: `mcp-shared/docs/organization-analytics_API実装完了報告_20251010.md`（✅ 完成）

**実装済みファイル**:
- `src/lib/middleware/api-key-auth.ts` - API Key認証ミドルウェア
- `src/lib/middleware/rate-limiter.ts` - Rate Limitミドルウェア
- `src/app/api/v2/departments/route.ts` - 部門マスタAPI
- `src/app/api/v2/employees/count/route.ts` - 職員数API
- テストファイル4件（30テスト全て成功）

---

### 6.3.5 ExecutiveReports API統合テスト

**概要**:
ExecutiveReportsページは、OrganizationAnalyticsと同じAPI（`GET /api/v2/employees/count`）を使用するため、追加のAPI実装は不要。VoiceDrive側でレスポンス変換を実装。

**前提条件**:
- ✅ API実装完了（2025年10月10日）- OrganizationAnalytics用と共通
- ✅ API利用承認済み（MEDICAL-APPROVAL-2025-1011-001）
- ✅ 統合テストスケジュール確定（2025年10月25日）

#### 統合テスト日程

**日時**: 2025年10月25日（金）14:00-16:00
**所要時間**: 2時間
**参加者**: VoiceDriveチーム開発担当2名 + 医療システムチーム担当者
**実施方法**: オンライン（Teams/Zoom）

#### テストシナリオ（5シナリオ、20テストケース）

**シナリオ1: API認証テスト**（15分）
- TC-1.1: 正常な認証（JWT + API Key）
- TC-1.2: JWT Token無効
- TC-1.3: API Key無効
- TC-1.4: 認証ヘッダなし

**シナリオ2: レスポンス形式検証**（20分）
- TC-2.1: 全職員数取得
- TC-2.2: 部門別カウント取得
- TC-2.3: 施設絞り込み
- TC-2.4: 部門絞り込み
- TC-2.5: タイムスタンプ検証

**シナリオ3: エラーハンドリング検証**（25分）
- TC-3.1: Rate Limit超過
- TC-3.2: DB接続エラー（任意）
- TC-3.3: 不正なクエリパラメータ
- TC-3.4: 存在しない施設ID

**シナリオ4: パフォーマンステスト**（30分）
- TC-4.1: 単発リクエスト応答時間（< 500ms）
- TC-4.2: 50リクエスト連続実行
- TC-4.3: 同時接続テスト（5並列）
- TC-4.4: 大量データ時の応答時間（< 1000ms）

**シナリオ5: VoiceDrive統合テスト**（30分）
- TC-5.1: KPI参加率計算
- TC-5.2: 月次レポート生成
- TC-5.3: キャッシュ機能
- TC-5.4: キャッシュ有効期限

#### 医療システム側の準備事項

```bash
# テスト環境URL確認
https://medical-staging.example.com

# テストデータ準備（推奨、既存データで十分な場合は不要）
# - 職員総数: 150名程度
# - 部門: 5部門以上
# - 施設: 2施設以上
```

**合格基準**:
- [ ] 全20テストケース成功
- [ ] API応答時間 < 500ms（単発）、< 1000ms（大量データ）
- [ ] Rate Limit正常動作確認
- [ ] VoiceDrive ExecutiveReportServiceの正常動作確認

**推定工数**: 2時間（2025年10月25日）

**実装状況**:
- ✅ API実装完了（2025-10-10）- OrganizationAnalyticsと共通
- ✅ API利用承認（2025-10-11）
- ✅ 統合テストスケジュール確定（10月25日）
- ⏳ 統合テスト実施待ち（10月25日予定）

**関連ドキュメント**:
- [executive-reports_医療システム確認結果_20251011.md](../mcp-shared/docs/executive-reports_医療システム確認結果_20251011.md)
- [executive-reports_医療システム承認回答_20251011.md](../mcp-shared/docs/executive-reports_医療システム承認回答_20251011.md)
- VD-SCHEDULE-2025-1011-001（VoiceDriveチーム作成）

---

### 6.3.6 BoardPreparation & VoiceDrive側実装タスク

**概要**:
BoardPreparationページも、OrganizationAnalytics/ExecutiveReportsと同じAPI（`GET /api/v2/employees/count`）を使用するため、医療システム側で追加のAPI実装は不要。VoiceDrive側で以下の実装が必要。

**医療システム側の対応**:
- ✅ API実装完了（2025年10月10日）- OrganizationAnalytics用と共通
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要

**VoiceDrive側の実装タスク**:

#### タスク1: ExecutiveReports レスポンス変換実装

```typescript
// VoiceDrive: src/services/MedicalSystemClient.ts
export async function getEmployeeCountForReports() {
  const response = await fetch('/api/v2/employees/count', {
    headers: {
      'Authorization': `Bearer ${JWT_TOKEN}`,
      'X-API-Key': API_KEY
    }
  });

  const data = await response.json();

  // レスポンス変換
  return {
    totalEmployees: data.data.totalCount,  // ← フィールド名変換
    byDepartment: data.data.byDepartment.reduce((acc, dept) => {
      acc[dept.departmentName] = dept.count;
      return acc;
    }, {}),
    activeOnly: true,
    calculatedAt: data.meta.timestamp
  };
}
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🔴 HIGH

---

#### タスク2: ReportDistributionGroup テーブル作成

```prisma
// VoiceDrive: schema.prisma
model ReportDistributionGroup {
  id          String   @id @default(cuid())
  groupKey    String   @unique              // "board-members", "executives"
  groupName   String                        // "理事会メンバー", "経営幹部"
  description String?

  // メンバー管理（医療システムのEmployee IDを格納）
  memberIds   Json                           // ["EMP001", "EMP002", ...]

  // 配布設定
  autoSend    Boolean  @default(false)       // 自動配布ON/OFF
  sendTiming  String?                        // "immediately", "scheduled"

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("report_distribution_groups")
}
```

**マイグレーション**:
```bash
npx prisma migrate dev --name add_report_distribution_group
```

**初期データ投入**:
```typescript
// VoiceDrive: prisma/seed.ts
await prisma.reportDistributionGroup.createMany({
  data: [
    {
      groupKey: 'board-members',
      groupName: '理事会メンバー',
      memberIds: ['EMP001', 'EMP002', 'EMP003'],
      autoSend: true,
      sendTiming: 'immediately'
    },
    {
      groupKey: 'executives',
      groupName: '経営幹部',
      memberIds: ['EMP010', 'EMP011', 'EMP012', 'EMP013'],
      autoSend: false
    }
  ]
});
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🔴 HIGH

---

#### タスク3: S3 Lifecycle Policy設定（全期間保存）

```json
// AWS S3コンソール or AWS CLI
{
  "Rules": [
    {
      "Id": "BoardMeetingDocuments-Lifecycle",
      "Prefix": "board-meetings/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 1095, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存
      // 理由: Phase 18 VoiceAnalytics、Phase 19 CultureDevelopmentと同じポリシー
    },
    {
      "Id": "ExecutiveReports-Lifecycle",
      "Prefix": "reports/board/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 1095, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存（職員情報含む）
    },
    {
      "Id": "ChairmanProposals-Lifecycle",
      "Prefix": "chairman-proposals/",
      "Status": "Enabled",
      "Transitions": [
        { "Days": 365, "StorageClass": "GLACIER" }
      ]
      // Expiration設定なし = 全期間保存
    }
  ]
}
```

**設定方法**:
```bash
# AWS CLI
aws s3api put-bucket-lifecycle-configuration \
  --bucket voicedrive-documents \
  --lifecycle-configuration file://lifecycle-policy.json
```

**実装期間**: 0.5日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: BoardPreparation 統合実装

VoiceDrive側で以下のテーブルを実装（医療システム側は関与なし）:

```prisma
// VoiceDrive: schema.prisma

model BoardMeeting {
  id                  String    @id @default(cuid())
  meetingDate         DateTime
  meetingType         String    // 'regular' | 'extraordinary'
  fiscalYear          Int
  quarterNumber       Int?
  status              String    @default("planning") // 'planning' | 'confirmed' | 'completed'

  agendas             BoardMeetingAgenda[]

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@map("board_meetings")
}

model BoardAgendaCandidateSelection {
  id                  String    @id @default(cuid())
  agendaId            String
  selectedBy          String    // User.id
  selectionReason     String?
  priorityScore       Int       @default(5)
  selectedAt          DateTime  @default(now())

  agenda              BoardMeetingAgenda @relation(fields: [agendaId], references: [id])
  selector            User      @relation(fields: [selectedBy], references: [id])

  @@unique([agendaId, selectedBy])
  @@map("board_agenda_candidate_selections")
}

model ChairmanProposal {
  id                  String    @id @default(cuid())
  proposalTitle       String
  proposalType        String    // 'agenda-addition' | 'agenda-removal' | 'priority-change'
  targetAgendaId      String?
  proposalReason      String
  proposedBy          String    // User.id
  proposedAt          DateTime  @default(now())
  status              String    @default("pending") // 'pending' | 'approved' | 'rejected'

  targetAgenda        BoardMeetingAgenda? @relation(fields: [targetAgendaId], references: [id])
  proposer            User      @relation(fields: [proposedBy], references: [id])

  @@map("chairman_proposals")
}

// BoardMeetingAgendaテーブルに準備状況フィールドを追加
model BoardMeetingAgenda {
  // ... 既存フィールド

  // 🆕 準備状況管理フィールド
  preparationStatus          String?   @default("not-started") // 'not-started' | 'in-progress' | 'review' | 'completed'
  documentDraftStatus        String?   @default("not-started")
  presentationDraftStatus    String?   @default("not-started")
  documentS3Key              String?
  presentationS3Key          String?
  documentUploadedAt         DateTime?
  presentationUploadedAt     DateTime?
  responsibleDepartment      String?
  responsibleUserId          String?
  dueDate                    DateTime?

  candidateSelections        BoardAgendaCandidateSelection[]
  chairmanProposals          ChairmanProposal[]

  @@map("board_meeting_agendas")
}

// Userテーブルにリレーション追加
model User {
  // ... 既存フィールド

  agendaCandidateSelections  BoardAgendaCandidateSelection[]
  chairmanProposals          ChairmanProposal[]

  @@map("users")
}
```

**実装期間**: 5日（共通DB構築後）
**優先度**: 🟡 MEDIUM（ExecutiveReportsの後）

---

#### VoiceDrive実装スケジュール

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: APIレスポンス変換 | 1日 | 🔴 HIGH | ExecutiveReports/BoardPreparation共通 |
| **タスク2**: ReportDistributionGroup | 1日 | 🔴 HIGH | ExecutiveReports用 |
| **タスク3**: S3 Lifecycle Policy | 0.5日 | 🟡 MEDIUM | インフラ設定 |
| **タスク4**: BoardPreparation DB設計 | 5日 | 🟡 MEDIUM | Phase 2で実装 |

**合計**: 7.5日（共通DB構築後に実施）

**関連ドキュメント**:
- [board-preparation_医療システム確認結果_20251011.md](../mcp-shared/docs/board-preparation_医療システム確認結果_20251011.md)
- [executive-reports_医療システム確認結果_20251011.md](../mcp-shared/docs/executive-reports_医療システム確認結果_20251011.md)
- Phase 18 VoiceAnalytics、Phase 19 CultureDevelopment（全期間保存ポリシー参考）

---

### 6.3.7 BoardAgendaReview VoiceDrive側実装タスク

**概要**:
BoardAgendaReviewページは、Level 17（戦略企画部長・人事部長）が準備した理事会議題をLevel 18（理事長・法人事務局長）が事前確認・レビューする機能。完全にVoiceDrive内部のワークフローであり、医療システム側のデータは一切使用しない。

**医療システム側の対応**:
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要（VoiceDrive内部ワークフローのため）

**VoiceDrive側の実装タスク**:

#### タスク1: BoardMeetingAgendaテーブル拡張（理事長レビュー用）

```sql
-- VoiceDrive: マイグレーション
ALTER TABLE `board_meeting_agendas`
ADD COLUMN `key_points` JSON NULL AFTER `document_urls`,
ADD COLUMN `expected_discussion` TEXT NULL AFTER `key_points`,
ADD COLUMN `required_decision` TEXT NULL AFTER `expected_discussion`,
ADD COLUMN `chairman_review` VARCHAR(191) NULL DEFAULT 'pending' AFTER `required_decision`,
ADD COLUMN `chairman_comment` TEXT NULL AFTER `chairman_review`,
ADD COLUMN `chairman_reviewed_by` VARCHAR(191) NULL AFTER `chairman_comment`,
ADD COLUMN `chairman_reviewed_at` DATETIME(3) NULL AFTER `chairman_reviewed_by`;

-- インデックス追加
CREATE INDEX `idx_bma_chairman_review` ON `board_meeting_agendas`(`chairman_review`);
CREATE INDEX `idx_bma_chairman_reviewed_at` ON `board_meeting_agendas`(`chairman_reviewed_at`);
CREATE INDEX `idx_bma_meeting_review` ON `board_meeting_agendas`(`board_meeting_id`, `chairman_review`);

-- 外部キー制約追加
ALTER TABLE `board_meeting_agendas`
ADD CONSTRAINT `fk_bma_chairman_reviewed_by`
FOREIGN KEY (`chairman_reviewed_by`) REFERENCES `users`(`id`)
ON DELETE SET NULL ON UPDATE CASCADE;
```

**Prismaスキーマ**:
```prisma
// VoiceDrive: schema.prisma
model BoardMeetingAgenda {
  // ... 既存フィールド（BoardPreparationで追加済み）

  // 🆕 理事長レビュー用フィールド（BoardAgendaReview）
  keyPoints            Json?      // ["スコア74点(前期比+6点)", ...]
  expectedDiscussion   String?    @db.Text
  requiredDecision     String?    @db.Text
  chairmanReview       String?    @default("pending") // 'pending' | 'approved' | 'needs_revision' | 'rejected'
  chairmanComment      String?    @db.Text
  chairmanReviewedBy   String?
  chairmanReviewedAt   DateTime?

  chairmanReviewer     User?      @relation("AgendaChairmanReviewer", fields: [chairmanReviewedBy], references: [id])

  @@map("board_meeting_agendas")
}

model User {
  // ... 既存フィールド

  reviewedAgendas      BoardMeetingAgenda[]  @relation("AgendaChairmanReviewer")

  @@map("users")
}
```

**実装期間**: 1日（共通DB構築後、BoardPreparationテーブル作成後）
**優先度**: 🟡 MEDIUM（BoardPreparationの後）

---

#### タスク2: BoardAgendaReviewService実装

```typescript
// VoiceDrive: src/services/BoardAgendaReviewService.ts
class BoardAgendaReviewService {
  // 次回理事会の議題一覧を取得
  async getAgendasForReview(
    boardMeetingId: string
  ): Promise<BoardMeetingAgenda[]> {
    return await prisma.boardMeetingAgenda.findMany({
      where: { boardMeetingId },
      orderBy: { agendaOrder: 'asc' },
      include: {
        presenter: true,
        chairmanReviewer: true
      }
    });
  }

  // 理事長レビューを実行
  async submitChairmanReview(
    agendaId: string,
    reviewData: {
      status: 'approved' | 'needs_revision' | 'rejected';
      comment?: string;
      reviewedBy: string;
    }
  ): Promise<BoardMeetingAgenda> {
    // バリデーション1: 修正依頼・却下時はコメント必須
    if (
      (reviewData.status === 'needs_revision' ||
       reviewData.status === 'rejected') &&
      !reviewData.comment
    ) {
      throw new Error('修正依頼または却下時はコメントが必須です');
    }

    // バリデーション2: レビュー済み議題は再レビュー不可
    const agenda = await prisma.boardMeetingAgenda.findUnique({
      where: { id: agendaId }
    });

    if (agenda.chairmanReview && agenda.chairmanReview !== 'pending') {
      throw new Error('この議題は既にレビュー済みです');
    }

    // バリデーション3: Level 18権限チェック
    const reviewer = await prisma.user.findUnique({
      where: { id: reviewData.reviewedBy }
    });

    if (reviewer.permissionLevel < 18) {
      throw new ForbiddenError('理事会議題レビューの権限がありません');
    }

    // レビュー実行
    const result = await prisma.boardMeetingAgenda.update({
      where: { id: agendaId },
      data: {
        chairmanReview: reviewData.status,
        chairmanComment: reviewData.comment,
        chairmanReviewedBy: reviewData.reviewedBy,
        chairmanReviewedAt: new Date()
      }
    });

    // Level 17への通知送信
    await this.notifyLevel17(agendaId, reviewData);

    // 監査ログ記録
    await auditLog.create({
      userId: reviewData.reviewedBy,
      action: 'CHAIRMAN_REVIEW_AGENDA',
      resource: agendaId,
      details: { status: reviewData.status, comment: reviewData.comment }
    });

    return result;
  }

  // Level 17への通知
  async notifyLevel17(
    agendaId: string,
    reviewResult: { status: string; comment?: string }
  ): Promise<void> {
    const agenda = await prisma.boardMeetingAgenda.findUnique({
      where: { id: agendaId },
      include: { presenter: true }
    });

    const notificationMessage =
      reviewResult.status === 'approved'
        ? `理事会議題「${agenda.item}」が承認されました。`
        : reviewResult.status === 'needs_revision'
        ? `理事会議題「${agenda.item}」の修正依頼があります。理事長コメント: ${reviewResult.comment}`
        : `理事会議題「${agenda.item}」が却下されました。理事長コメント: ${reviewResult.comment}`;

    // 議題作成者（Level 17）に通知
    await prisma.notification.create({
      data: {
        userId: agenda.presenterId,
        category: 'board_agenda_review',
        title: '理事会議題レビュー結果',
        message: notificationMessage,
        link: '/board-preparation',
        priority: reviewResult.status === 'approved' ? 'normal' : 'high',
        isRead: false
      }
    });

    // Level 17全員にも通知
    const level17Users = await prisma.user.findMany({
      where: { permissionLevel: { gte: 17, lt: 18 } }
    });

    for (const user of level17Users) {
      if (user.id !== agenda.presenterId) {
        await prisma.notification.create({
          data: {
            userId: user.id,
            category: 'board_agenda_review',
            title: '理事会議題レビュー結果（参考）',
            message: notificationMessage,
            link: '/board-preparation',
            priority: 'normal',
            isRead: false
          }
        });
      }
    }
  }

  // レビュー統計を取得
  async getReviewStats(boardMeetingId: string): Promise<ReviewStats> {
    const agendas = await prisma.boardMeetingAgenda.findMany({
      where: { boardMeetingId }
    });

    const totalAgendas = agendas.length;
    const approvedCount = agendas.filter(a => a.chairmanReview === 'approved').length;
    const needsRevisionCount = agendas.filter(a => a.chairmanReview === 'needs_revision').length;
    const rejectedCount = agendas.filter(a => a.chairmanReview === 'rejected').length;
    const pendingCount = agendas.filter(a => !a.chairmanReview || a.chairmanReview === 'pending').length;

    return {
      totalAgendas,
      approvedCount,
      needsRevisionCount,
      rejectedCount,
      pendingCount,
      completionRate: ((approvedCount + needsRevisionCount + rejectedCount) / totalAgendas) * 100
    };
  }
}
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク3: API実装（5エンドポイント）

```typescript
// VoiceDrive: src/app/api/board-agenda-review/[...]/route.ts

// 1. GET /api/board-agenda-review/:boardMeetingId/agendas - 議題一覧取得
export async function GET(
  req: Request,
  { params }: { params: { boardMeetingId: string } }
) {
  const user = await authenticate(req);
  if (user.permissionLevel < 18) {
    return Response.json({ error: 'Forbidden' }, { status: 403 });
  }

  const agendas = await service.getAgendasForReview(params.boardMeetingId);
  return Response.json(agendas);
}

// 2. GET /api/board-agenda-review/agendas/:agendaId - 議題詳細取得
// 3. POST /api/board-agenda-review/agendas/:agendaId/review - 理事長レビュー実行
// 4. GET /api/board-agenda-review/:boardMeetingId/stats - レビュー統計取得
// 5. GET /api/board-agenda-review/next-meeting - 次回理事会情報取得
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: フロントエンド実装

```typescript
// VoiceDrive: コンポーネント実装

// 1. AgendaReviewCard - 議題レビューカード
// 2. ReviewStatusBadge - レビューステータスバッジ
const getStatusStyle = (status: string) => {
  switch (status) {
    case 'pending':
      return { bg: 'yellow-100', text: 'yellow-800', label: 'レビュー待ち' };
    case 'approved':
      return { bg: 'green-100', text: 'green-800', label: '承認済み' };
    case 'needs_revision':
      return { bg: 'orange-100', text: 'orange-800', label: '修正依頼' };
    case 'rejected':
      return { bg: 'red-100', text: 'red-800', label: '却下' };
  }
};

// 3. ReviewCommentDialog - レビューコメント入力ダイアログ
// 4. MeetingSummaryCards - 理事会サマリーカード

// 5. useBoardAgendaReview - カスタムフック
const useBoardAgendaReview = (boardMeetingId: string) => {
  const { data: agendas, isLoading, error } = useSWR(
    `/api/board-agenda-review/${boardMeetingId}/agendas`,
    fetcher
  );

  const submitReview = async (
    agendaId: string,
    status: 'approved' | 'needs_revision' | 'rejected',
    comment?: string
  ) => {
    await fetch(`/api/board-agenda-review/agendas/${agendaId}/review`, {
      method: 'POST',
      body: JSON.stringify({ status, comment })
    });
    mutate();
  };

  return { agendas, isLoading, error, submitReview };
};
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク5: 運用実装（レビュー期限管理・監視）

```typescript
// VoiceDrive: バッチ処理実装

// 1. 理事会3日前にリマインダー通知
async function sendReviewReminder() {
  const threeDaysLater = new Date();
  threeDaysLater.setDate(threeDaysLater.getDate() + 3);

  const upcomingMeetings = await prisma.boardMeeting.findMany({
    where: {
      meetingDate: { gte: new Date(), lte: threeDaysLater },
      status: 'planning'
    },
    include: { agendas: true }
  });

  for (const meeting of upcomingMeetings) {
    const pendingAgendas = meeting.agendas.filter(
      a => a.chairmanReview === 'pending'
    );

    if (pendingAgendas.length > 0) {
      // Level 18に通知
      await notifyLevel18({
        title: '理事会議題レビューのリマインダー',
        message: `${meeting.meetingDate.toLocaleDateString('ja-JP')}の理事会まで3日です。未レビュー議題が${pendingAgendas.length}件あります。`,
        priority: 'high'
      });
    }
  }
}

// 毎日午前9時に実行（cron: 0 9 * * *）

// 2. レビュー完了率の監視
async function monitorReviewCompletionRate() {
  const upcomingMeetings = await prisma.boardMeeting.findMany({
    where: {
      meetingDate: { gte: new Date() },
      status: 'planning'
    },
    include: { agendas: true }
  });

  for (const meeting of upcomingMeetings) {
    const totalAgendas = meeting.agendas.length;
    const reviewedAgendas = meeting.agendas.filter(
      a => a.chairmanReview && a.chairmanReview !== 'pending'
    ).length;

    const completionRate = reviewedAgendas / totalAgendas;
    const daysUntilMeeting = Math.ceil(
      (meeting.meetingDate.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)
    );

    // アラート条件: 理事会まで3日を切り、レビュー完了率80%未満
    if (daysUntilMeeting < 3 && completionRate < 0.8) {
      await notifySlack({
        channel: '#board-meeting-alerts',
        message: `:warning: 理事会まで${daysUntilMeeting}日ですが、議題レビュー完了率が${(completionRate * 100).toFixed(1)}%です（${reviewedAgendas}/${totalAgendas}件）`
      });
    }
  }
}

// 毎日午前10時、午後3時に実行
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟢 LOW（Phase 2で実装）

---

#### VoiceDrive実装スケジュール（BoardAgendaReview）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: BoardMeetingAgendaテーブル拡張 | 1日 | 🟡 MEDIUM | BoardPreparation後に実装 |
| **タスク2**: BoardAgendaReviewService | 2日 | 🟡 MEDIUM | レビュー実行・通知機能 |
| **タスク3**: API実装（5エンドポイント） | 1日 | 🟡 MEDIUM | Level 18権限チェック |
| **タスク4**: フロントエンド実装 | 2日 | 🟡 MEDIUM | 4コンポーネント + 1フック |
| **タスク5**: 運用実装（リマインダー・監視） | 1日 | 🟢 LOW | Phase 2で実装 |

**合計**: 7日（共通DB構築後に実施、BoardPreparation実装後）

**テスト要件**:
- ユニットテスト: 15ケース以上
- API統合テスト: 10ケース以上
- エンドツーエンドテスト: 1ケース（Level 17 → Level 18 ワークフロー全体）

**関連ドキュメント**:
- [board-agenda-review_医療システム確認結果_20251011.md](../mcp-shared/docs/board-agenda-review_医療システム確認結果_20251011.md)
- [board-preparation_医療システム確認結果_20251011.md](../mcp-shared/docs/board-preparation_医療システム確認結果_20251011.md)
- BoardPreparationとのワークフロー連携（Level 17 → Level 18）

---

### 6.3.8 BoardDecisionFollow VoiceDrive側実装タスク

**概要**:
BoardDecisionFollowページは、理事会で決定された事項の実施進捗を追跡・管理する機能。VoiceDrive内部のプロジェクト管理機能であり、医療システム側のデータは既存API（facilities, departments）のみ使用。

**医療システム側の対応**:
- ✅ 確認結果ドキュメント作成済み（2025年10月11日）
- ❌ 追加実装不要（VoiceDrive内部プロジェクト管理機能のため）
- ✅ 既存API利用（GET /api/v2/facilities, GET /api/v2/departments）

**VoiceDrive側の実装タスク**:

#### タスク1: データベース構築（3テーブル新規作成）

```prisma
// VoiceDrive: schema.prisma

// 1. 理事会決定事項テーブル
model BoardDecision {
  id                      String    @id @default(cuid())
  boardMeetingId          String    @map("board_meeting_id")
  meetingDate             DateTime  @map("meeting_date")
  title                   String
  category                String    // "システム導入", "人事制度", "IT・システム", "人材育成"
  description             String    @db.Text
  decision                String    @db.Text
  implementationDeadline  DateTime  @map("implementation_deadline")
  responsibleDept         String    @map("responsible_dept")  // 担当部門名（キャッシュ）
  responsibleDeptId       String?   @map("responsible_dept_id")  // 医療システム部門ID
  affectedFacilities      Json      @map("affected_facilities")  // 影響施設ID配列
  status                  String    @default("on_track")  // "completed", "on_track", "at_risk", "delayed"
  progress                Int       @default(0)  // 0-100
  lastUpdate              DateTime  @default(now()) @map("last_update")
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  boardMeeting            BoardMeeting @relation("BoardDecisions", fields: [boardMeetingId], references: [id], onDelete: Cascade)
  milestones              BoardDecisionMilestone[]
  facilityImplementations BoardDecisionFacilityImplementation[]

  @@index([boardMeetingId])
  @@index([status])
  @@index([implementationDeadline])
  @@index([category])
  @@map("board_decisions")
}

// 2. マイルストーンテーブル
model BoardDecisionMilestone {
  id                String        @id @default(cuid())
  boardDecisionId   String        @map("board_decision_id")
  title             String
  deadline          DateTime
  status            String        @default("pending")  // "completed", "in_progress", "pending", "delayed"
  assignee          String
  assigneeId        String?       @map("assignee_id")
  sortOrder         Int           @default(0) @map("sort_order")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  completedAt       DateTime?     @map("completed_at")

  boardDecision     BoardDecision @relation(fields: [boardDecisionId], references: [id], onDelete: Cascade)

  @@index([boardDecisionId])
  @@index([status])
  @@index([deadline])
  @@index([sortOrder])
  @@map("board_decision_milestones")
}

// 3. 施設別実施状況テーブル
model BoardDecisionFacilityImplementation {
  id                String        @id @default(cuid())
  boardDecisionId   String        @map("board_decision_id")
  facilityId        String        @map("facility_id")  // 医療システム施設ID
  facilityName      String        @map("facility_name")  // 施設名（キャッシュ）
  status            String        @default("not_started")  // "completed", "in_progress", "not_started"
  progress          Int           @default(0)  // 0-100
  note              String?
  startedAt         DateTime?     @map("started_at")
  completedAt       DateTime?     @map("completed_at")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  boardDecision     BoardDecision @relation(fields: [boardDecisionId], references: [id], onDelete: Cascade)

  @@unique([boardDecisionId, facilityId])
  @@index([boardDecisionId])
  @@index([facilityId])
  @@index([status])
  @@map("board_decision_facility_implementations")
}

// 4. BoardMeeting リレーション追加
model BoardMeeting {
  // ... 既存フィールド

  decisions           BoardDecision[]      @relation("BoardDecisions")
}
```

**マイグレーション実行**:
```bash
npx prisma migrate dev --name add_board_decision_follow_tables
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM（BoardAgendaReviewの後）

---

#### タスク2: BoardDecisionFollowService実装

```typescript
// VoiceDrive: src/services/BoardDecisionFollowService.ts
class BoardDecisionFollowService {
  // 決定事項作成（医療システムAPIから施設名をキャッシュ）
  async createDecision(data: {
    boardMeetingId: string;
    title: string;
    category: string;
    description: string;
    decision: string;
    implementationDeadline: Date;
    responsibleDept: string;
    affectedFacilities: string[];
    milestones: { title: string; deadline: Date; assignee: string; }[];
  }): Promise<BoardDecision> {
    // 医療システムから施設マスタを取得
    const facilitiesResponse = await fetch(`${MEDICAL_SYSTEM_URL}/api/v2/facilities`, {
      headers: {
        'Authorization': `Bearer ${JWT_TOKEN}`,
        'X-API-Key': API_KEY
      }
    });
    const facilitiesData = await facilitiesResponse.json();
    const facilitiesMap = new Map(
      facilitiesData.facilities.map(f => [f.facilityId, f.name])
    );

    // 理事会情報取得
    const boardMeeting = await prisma.boardMeeting.findUnique({
      where: { id: data.boardMeetingId }
    });

    // 決定事項作成
    const decision = await prisma.boardDecision.create({
      data: {
        boardMeetingId: data.boardMeetingId,
        meetingDate: boardMeeting!.meetingDate,
        title: data.title,
        category: data.category,
        description: data.description,
        decision: data.decision,
        implementationDeadline: data.implementationDeadline,
        responsibleDept: data.responsibleDept,
        affectedFacilities: data.affectedFacilities,
        status: 'on_track',
        progress: 0
      }
    });

    // マイルストーン作成
    await prisma.boardDecisionMilestone.createMany({
      data: data.milestones.map((m, index) => ({
        boardDecisionId: decision.id,
        title: m.title,
        deadline: m.deadline,
        assignee: m.assignee,
        status: 'pending',
        sortOrder: index
      }))
    });

    // 施設別実施状況を初期化
    await prisma.boardDecisionFacilityImplementation.createMany({
      data: data.affectedFacilities.map(facilityId => ({
        boardDecisionId: decision.id,
        facilityId,
        facilityName: facilitiesMap.get(facilityId) || facilityId,
        status: 'not_started',
        progress: 0
      }))
    });

    return decision;
  }

  // マイルストーン更新 + 進捗自動再計算
  async updateMilestone(milestoneId: string, data: {
    status?: string;
    completedAt?: Date;
  }): Promise<void> {
    await prisma.boardDecisionMilestone.update({
      where: { id: milestoneId },
      data
    });

    // 親の決定事項の進捗を再計算
    const milestone = await prisma.boardDecisionMilestone.findUnique({
      where: { id: milestoneId },
      include: { boardDecision: true }
    });

    const allMilestones = await prisma.boardDecisionMilestone.findMany({
      where: { boardDecisionId: milestone!.boardDecisionId }
    });

    const completedCount = allMilestones.filter(m => m.status === 'completed').length;
    const progress = Math.round((completedCount / allMilestones.length) * 100);
    const status = this.calculateStatus(allMilestones);

    await prisma.boardDecision.update({
      where: { id: milestone!.boardDecisionId },
      data: { progress, status, lastUpdate: new Date() }
    });
  }

  // ステータス自動判定ロジック
  private calculateStatus(milestones: BoardDecisionMilestone[]): string {
    const now = new Date();

    const completedCount = milestones.filter(m => m.status === 'completed').length;
    if (completedCount === milestones.length) {
      return 'completed';
    }

    const hasDelayed = milestones.some(m =>
      m.status !== 'completed' && m.deadline < now
    );
    if (hasDelayed) {
      return 'delayed';
    }

    const hasAtRisk = milestones.some(m => {
      const daysToDeadline = Math.floor(
        (m.deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );
      return m.status !== 'completed' && daysToDeadline > 0 && daysToDeadline <= 7;
    });
    if (hasAtRisk) {
      return 'at_risk';
    }

    return 'on_track';
  }

  // 施設別実施状況更新 + 全体進捗再計算
  async updateFacilityImplementation(
    decisionId: string,
    facilityId: string,
    data: { status?: string; progress?: number; note?: string; }
  ): Promise<void> {
    await prisma.boardDecisionFacilityImplementation.update({
      where: {
        boardDecisionId_facilityId: { boardDecisionId: decisionId, facilityId }
      },
      data
    });

    // 全施設の平均進捗率を再計算
    const implementations = await prisma.boardDecisionFacilityImplementation.findMany({
      where: { boardDecisionId: decisionId }
    });
    const totalProgress = implementations.reduce((sum, impl) => sum + impl.progress, 0);
    const averageProgress = Math.round(totalProgress / implementations.length);

    await prisma.boardDecision.update({
      where: { id: decisionId },
      data: { progress: averageProgress, lastUpdate: new Date() }
    });
  }
}
```

**実装期間**: 3日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク3: API実装（5エンドポイント）

```typescript
// VoiceDrive: API実装

// 1. GET /api/board-decisions - 決定事項一覧取得
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const status = searchParams.get('status') || 'all';
  const category = searchParams.get('category');

  const where: any = {};
  if (status !== 'all') where.status = status;
  if (category) where.category = category;

  const decisions = await prisma.boardDecision.findMany({
    where,
    include: {
      milestones: { orderBy: { sortOrder: 'asc' } },
      facilityImplementations: true,
      boardMeeting: true
    },
    orderBy: { implementationDeadline: 'asc' }
  });

  const summary = {
    completed: decisions.filter(d => d.status === 'completed').length,
    on_track: decisions.filter(d => d.status === 'on_track').length,
    at_risk: decisions.filter(d => d.status === 'at_risk').length,
    delayed: decisions.filter(d => d.status === 'delayed').length
  };

  return NextResponse.json({ decisions, summary });
}

// 2. GET /api/board-decisions/:id/facility-implementations - 施設別実施状況取得
// 3. PUT /api/board-decisions/:id/milestones/:milestoneId - マイルストーン更新
// 4. PUT /api/board-decisions/:id/facility-implementations/:facilityId - 施設別実施状況更新
// 5. POST /api/board-decisions - 決定事項作成
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### タスク4: バッチ処理実装（2つ）

```typescript
// VoiceDrive: バッチ処理

// 1. 施設名キャッシュ更新バッチ（毎日午前2時実行）
async function updateFacilityNameCache() {
  const response = await fetch(`${MEDICAL_SYSTEM_URL}/api/v2/facilities`, {
    headers: {
      'Authorization': `Bearer ${JWT_TOKEN}`,
      'X-API-Key': API_KEY
    }
  });

  if (!response.ok) {
    console.error('[Batch] Failed to fetch facilities from medical system');
    return;
  }

  const facilitiesData = await response.json();
  const facilitiesMap = new Map(
    facilitiesData.facilities.map(f => [f.facilityId, f.name])
  );

  const implementations = await prisma.boardDecisionFacilityImplementation.findMany();

  for (const impl of implementations) {
    const latestFacilityName = facilitiesMap.get(impl.facilityId);
    if (latestFacilityName && latestFacilityName !== impl.facilityName) {
      await prisma.boardDecisionFacilityImplementation.update({
        where: { id: impl.id },
        data: { facilityName: latestFacilityName }
      });
    }
  }
}

// 2. 遅延アラート通知バッチ（毎日午前9時実行）
async function sendDelayedAlerts() {
  const now = new Date();

  const alertDecisions = await prisma.boardDecision.findMany({
    where: { status: { in: ['delayed', 'at_risk'] } },
    include: { milestones: true, boardMeeting: true }
  });

  for (const decision of alertDecisions) {
    const delayedMilestones = decision.milestones.filter(m =>
      m.status !== 'completed' && m.deadline < now
    );

    if (delayedMilestones.length > 0) {
      // Level 18（理事長）に通知
      await prisma.notification.create({
        data: {
          userId: 'LEVEL18_USER_ID',
          category: 'board_decision_alert',
          title: '理事会決定事項の実施遅延',
          message: `「${decision.title}」の実施が遅延しています。${delayedMilestones.length}件のマイルストーンが期限切れです。`,
          link: '/board-decision-follow',
          priority: 'high',
          isRead: false
        }
      });
    }
  }
}
```

**実装期間**: 1日（共通DB構築後）
**優先度**: 🟢 LOW（Phase 2で実装）

---

#### タスク5: フロントエンド実装

```typescript
// VoiceDrive: カスタムフック・コンポーネント

// 1. useBoardDecisions カスタムフック
const useBoardDecisions = (filter?: { status?: string; category?: string }) => {
  const queryString = new URLSearchParams(filter as any).toString();
  const { data, error, mutate } = useSWR(
    `/api/board-decisions?${queryString}`,
    fetcher,
    { refreshInterval: 60000, revalidateOnFocus: true }
  );

  const updateMilestone = async (decisionId: string, milestoneId: string, status: string) => {
    await fetch(`/api/board-decisions/${decisionId}/milestones/${milestoneId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        status,
        completedAt: status === 'completed' ? new Date().toISOString() : null,
        updatedAt: new Date().toISOString()  // 楽観的ロック用
      })
    });
    mutate();
  };

  return {
    decisions: data?.decisions || [],
    summary: data?.summary || {},
    isLoading: !error && !data,
    isError: error,
    updateMilestone,
    refresh: mutate
  };
};

// 2. FacilityImplementationProgress コンポーネント
const FacilityImplementationProgress = ({ implementation }) => {
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return 'bg-green-500';
      case 'in_progress': return 'bg-blue-500';
      case 'not_started': return 'bg-gray-300';
    }
  };

  return (
    <div className="flex items-center gap-4">
      <div className="flex-1">
        <div className="flex justify-between text-sm mb-1">
          <span>{implementation.facilityName}</span>
          <span className="text-gray-600">{implementation.progress}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className={`h-2 rounded-full transition-all duration-300 ${getStatusColor(implementation.status)}`}
            style={{ width: `${implementation.progress}%` }}
          />
        </div>
      </div>
    </div>
  );
};
```

**実装期間**: 2日（共通DB構築後）
**優先度**: 🟡 MEDIUM

---

#### VoiceDrive実装スケジュール（BoardDecisionFollow）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: データベース構築（3テーブル） | 2日 | 🟡 MEDIUM | BoardAgendaReview後に実装 |
| **タスク2**: BoardDecisionFollowService | 3日 | 🟡 MEDIUM | 進捗自動計算・ステータス判定 |
| **タスク3**: API実装（5エンドポイント） | 2日 | 🟡 MEDIUM | Level 18権限チェック |
| **タスク4**: バッチ処理実装 | 1日 | 🟢 LOW | 施設名キャッシュ・遅延アラート |
| **タスク5**: フロントエンド実装 | 2日 | 🟡 MEDIUM | カスタムフック + プログレスバー |

**合計**: 10日（共通DB構築後に実施、BoardAgendaReview実装後）

**テスト要件**:
- ユニットテスト: 20ケース以上（進捗計算、ステータス判定）
- API統合テスト: 15ケース以上
- エンドツーエンドテスト: 1ケース（決定事項作成→マイルストーン更新→進捗確認）

**医療システムAPIの利用**:
- GET /api/v2/facilities（施設マスタ取得）- 決定事項作成時、日次キャッシュ更新時
- GET /api/v2/departments（部門マスタ取得）- 決定事項作成時

**関連ドキュメント**:
- [board-decision-follow_医療システム確認結果_20251011.md](../mcp-shared/docs/board-decision-follow_医療システム確認結果_20251011.md)
- [board-decision-follow_DB要件分析_20251011.md](../mcp-shared/docs/board-decision-follow_DB要件分析_20251011.md)
- 医療システム既存API（facilities, departments）

---

### 6.3.9 ProjectTracking VoiceDrive側実装タスク

**概要**: プロジェクト追跡ページ実装（ユーザーの投稿・投票・参加プロジェクト一覧）

**医療システムAPI依存**: なし（VoiceDrive内部データのみ使用）

**実装完了期限**: BoardDecisionFollow実装後 + 4日

**関連ドキュメント**:
- [project-tracking_医療システム確認結果_20251011.md](../mcp-shared/docs/project-tracking_医療システム確認結果_20251011.md)

---

#### タスク1: 複合インデックス追加（パフォーマンス最適化）

**実装期間**: 1日
**優先度**: 🔴 HIGH（パフォーマンスに直接影響）

**実装内容**:

既存のPost/Voteテーブルに複合インデックスを追加し、クエリパフォーマンスを10-50倍向上させる。

##### マイグレーション1: Post複合インデックス
```prisma
// prisma/schema.prisma

model Post {
  id          String   @id @default(cuid())
  authorId    String
  type        String   // 'project', 'discussion', etc.
  title       String
  description String?
  status      String   // 'active', 'completed', 'archived'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  votes    Vote[]
  comments Comment[]

  @@index([authorId, type, createdAt])  // 新規追加
}
```

**SQLマイグレーション**:
```sql
-- Migration: 20251011_add_post_author_type_created_index

CREATE INDEX "Post_authorId_type_createdAt_idx"
ON "Post"("authorId", "type", "createdAt" DESC);

-- 実行時間: 約5-30秒（Postテーブルサイズに依存）
-- ディスク使用量増加: Postレコード数 × 約50バイト
```

##### マイグレーション2: Vote複合インデックス
```prisma
// prisma/schema.prisma

model Vote {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  score     Int      @default(1)  // 1-10
  timestamp DateTime @default(now())

  post Post @relation(fields: [postId], references: [id])

  @@unique([userId, postId])
  @@index([userId, timestamp])  // 新規追加
}
```

**SQLマイグレーション**:
```sql
-- Migration: 20251011_add_vote_user_timestamp_index

CREATE INDEX "Vote_userId_timestamp_idx"
ON "Vote"("userId", "timestamp" DESC);

-- 実行時間: 約3-20秒（Voteテーブルサイズに依存）
-- ディスク使用量増加: Voteレコード数 × 約50バイト
```

**マイグレーション実行**:
```bash
# インデックス追加
npx prisma migrate dev --name add_project_tracking_indexes

# 本番環境適用
npx prisma migrate deploy
```

**検証**:
```sql
-- インデックス使用確認
EXPLAIN ANALYZE
SELECT * FROM "Post"
WHERE "authorId" = 'user-001'
  AND "type" = 'project'
ORDER BY "createdAt" DESC
LIMIT 10;

-- 結果に"Index Scan using Post_authorId_type_createdAt_idx"が含まれることを確認
```

---

#### タスク2: ProjectTrackingService実装

**実装期間**: 2日
**優先度**: 🔴 HIGH

**実装内容**:

プロジェクト追跡データ取得のためのサービス層を実装。

```typescript
// src/services/ProjectTrackingService.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ProjectTrackingService {
  /**
   * ユーザーが提案したプロジェクト一覧取得
   */
  async getMyProjects(userId: string, options: {
    limit?: number;
    offset?: number;
    status?: 'active' | 'completed' | 'archived';
  }) {
    const { limit = 10, offset = 0, status } = options;

    const where: any = {
      authorId: userId,
      type: 'project'
    };

    if (status) {
      where.status = status;
    }

    const [posts, totalCount] = await Promise.all([
      prisma.post.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: offset,
        take: limit,
        include: {
          _count: {
            select: {
              votes: true,
              comments: true
            }
          }
        }
      }),
      prisma.post.count({ where })
    ]);

    return {
      projects: posts.map(post => ({
        id: post.id,
        title: post.title,
        description: post.description,
        status: post.status,
        createdAt: post.createdAt,
        votesCount: post._count.votes,
        commentsCount: post._count.comments
      })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーが投票したプロジェクト一覧取得
   */
  async getVotedProjects(userId: string, options: {
    limit?: number;
    offset?: number;
  }) {
    const { limit = 10, offset = 0 } = options;

    const [votes, totalCount] = await Promise.all([
      prisma.vote.findMany({
        where: { userId },
        orderBy: { timestamp: 'desc' },
        skip: offset,
        take: limit,
        include: {
          post: {
            include: {
              _count: {
                select: {
                  votes: true,
                  comments: true
                }
              }
            }
          }
        }
      }),
      prisma.vote.count({ where: { userId } })
    ]);

    return {
      projects: votes
        .filter(vote => vote.post?.type === 'project')
        .map(vote => ({
          id: vote.post.id,
          title: vote.post.title,
          description: vote.post.description,
          status: vote.post.status,
          votedAt: vote.timestamp,
          myScore: vote.score,
          totalVotesCount: vote.post._count.votes,
          commentsCount: vote.post._count.comments
        })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーがコメント参加したプロジェクト一覧取得
   */
  async getJoinedProjects(userId: string, options: {
    limit?: number;
    offset?: number;
  }) {
    const { limit = 10, offset = 0 } = options;

    // ユニークなpostIdを取得
    const uniquePostIds = await prisma.comment.groupBy({
      by: ['postId'],
      where: {
        authorId: userId,
        post: {
          type: 'project'
        }
      },
      _max: {
        createdAt: true
      },
      orderBy: {
        _max: {
          createdAt: 'desc'
        }
      },
      skip: offset,
      take: limit
    });

    const postIds = uniquePostIds.map(g => g.postId);

    const posts = await prisma.post.findMany({
      where: {
        id: { in: postIds }
      },
      include: {
        _count: {
          select: {
            votes: true,
            comments: true
          }
        }
      }
    });

    const totalCount = await prisma.comment.groupBy({
      by: ['postId'],
      where: {
        authorId: userId,
        post: { type: 'project' }
      }
    }).then(results => results.length);

    return {
      projects: posts.map(post => ({
        id: post.id,
        title: post.title,
        description: post.description,
        status: post.status,
        votesCount: post._count.votes,
        commentsCount: post._count.comments
      })),
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * ユーザーのプロジェクトアクティビティ統計取得
   */
  async getProjectStats(userId: string) {
    const [
      myPostsCount,
      votedPostsCount,
      commentedProjectsCount,
      achievedCount
    ] = await Promise.all([
      prisma.post.count({
        where: {
          authorId: userId,
          type: 'project'
        }
      }),
      prisma.vote.count({
        where: {
          userId,
          post: { type: 'project' }
        }
      }),
      prisma.comment.groupBy({
        by: ['postId'],
        where: {
          authorId: userId,
          post: { type: 'project' }
        }
      }).then(results => results.length),
      prisma.post.count({
        where: {
          authorId: userId,
          type: 'project',
          status: 'completed'
        }
      })
    ]);

    return {
      myPostsCount,
      votedPostsCount,
      commentedProjectsCount,
      achievedCount
    };
  }
}
```

**テスト**:
```typescript
// tests/unit/ProjectTrackingService.test.ts

describe('ProjectTrackingService', () => {
  it('getMyProjects - 正常系', async () => {
    const result = await service.getMyProjects('user-001', { limit: 10, offset: 0 });
    expect(result.projects).toBeInstanceOf(Array);
    expect(result.pagination.total).toBeGreaterThanOrEqual(0);
  });

  it('getVotedProjects - 投票順でソート', async () => {
    const result = await service.getVotedProjects('user-001', { limit: 10, offset: 0 });
    expect(result.projects[0].votedAt >= result.projects[1].votedAt).toBe(true);
  });

  it('getProjectStats - 統計取得', async () => {
    const stats = await service.getProjectStats('user-001');
    expect(stats).toHaveProperty('myPostsCount');
    expect(stats).toHaveProperty('votedPostsCount');
    expect(stats).toHaveProperty('commentedProjectsCount');
    expect(stats).toHaveProperty('achievedCount');
  });
});
```

---

#### タスク3: API実装（4エンドポイント）

**実装期間**: 1日
**優先度**: 🔴 HIGH

**実装内容**:

ProjectTracking用の4つのAPIエンドポイントを実装。

##### API 1: 提案したプロジェクト一覧
```typescript
// src/app/api/project-tracking/my-projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);
    const status = searchParams.get('status') as 'active' | 'completed' | 'archived' | undefined;

    if (limit < 1 || limit > 100) {
      return NextResponse.json(
        { error: { code: 'INVALID_PARAMETER', message: 'limit must be between 1-100' } },
        { status: 400 }
      );
    }

    const result = await service.getMyProjects(user.id, { limit, offset, status });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/my-projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch my projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 2: 投票したプロジェクト一覧
```typescript
// src/app/api/project-tracking/voted-projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    const result = await service.getVotedProjects(user.id, { limit, offset });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/voted-projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch voted projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 3: 参加したプロジェクト一覧
```typescript
// src/app/api/project-tracking/joined-projects/route.ts
// （API 2と同様の構造、service.getJoinedProjectsを呼び出し）
```

##### API 4: プロジェクト統計
```typescript
// src/app/api/project-tracking/stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProjectTrackingService } from '@/services/ProjectTrackingService';
import { authenticateUser } from '@/lib/auth';

const service = new ProjectTrackingService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    const stats = await service.getProjectStats(user.id);

    return NextResponse.json({
      data: stats,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/project-tracking/stats error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch project stats',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

**APIテスト**:
```bash
# 提案したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/my-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 投票したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/voted-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 参加したプロジェクト一覧
curl -X GET "http://localhost:3000/api/project-tracking/joined-projects?limit=10" \
  -H "Authorization: Bearer $TOKEN"

# 統計取得
curl -X GET "http://localhost:3000/api/project-tracking/stats" \
  -H "Authorization: Bearer $TOKEN"
```

---

#### VoiceDrive実装スケジュール（ProjectTracking）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: 複合インデックス追加 | 1日 | 🔴 HIGH | BoardDecisionFollow後に実装、パフォーマンス必須 |
| **タスク2**: ProjectTrackingService | 2日 | 🔴 HIGH | 4メソッド実装、Promise.all並列化 |
| **タスク3**: API実装（4エンドポイント） | 1日 | 🔴 HIGH | 認証必須、エラーハンドリング |

**合計**: 4日（共通DB構築後に実施、BoardDecisionFollow実装後）

**テスト要件**:
- ユニットテスト: 10ケース以上（サービス層のみ）
- API統合テスト: 12ケース以上（4エンドポイント × 3ケース）
- パフォーマンステスト: 2ケース（複合インデックス効果検証）
- E2Eテスト: 1ケース（タブ切り替え動作確認）

**医療システムAPIの利用**: なし（VoiceDrive内部データのみ使用）

**特記事項**:
- ✅ 医療システムとの連携不要（最もシンプルな実装）
- ✅ 新しいテーブル追加不要（既存Post/Vote/Commentテーブルのみ使用）
- ⚠️ 複合インデックス必須（データ増加時のパフォーマンス劣化防止）
- 📊 スコア計算はフロントエンドで実施（DBに保存しない）

---

### 6.3.10 ProgressDashboard VoiceDrive側実装タスク

**概要**: 進捗ダッシュボード実装（複数部署・施設全体のプロジェクト進捗を俯瞰的に管理）

**医療システムAPI依存**: 既存APIのみ使用（facilities/departments/employees）

**実装完了期限**: ProjectTracking実装後 + 9日

**関連ドキュメント**:
- [progress-dashboard_医療システム確認結果_20251011.md](../mcp-shared/docs/progress-dashboard_医療システム確認結果_20251011.md)

---

#### タスク1: データベース構築（2テーブル追加 + Post拡張）

**実装期間**: 1.5日
**優先度**: 🔴 HIGH（コア機能の基盤）

**実装内容**:

既存Postテーブルにプロジェクト管理フィールドを追加し、マイルストーン・チームメンバー管理用の新規テーブルを作成。

##### Postテーブル拡張

```prisma
model Post {
  // ... 既存フィールド

  // ProgressDashboard統合実装（2025-10-11）
  projectDueDate      DateTime? @map("project_due_date")      // プロジェクト期限
  projectLevel        String?   @map("project_level")         // 'team' | 'department' | 'facility' | 'organization'
  projectProgress     Int?      @default(0) @map("project_progress")  // 進捗率（0-100）

  // Relations
  milestones          ProjectMilestone[]   @relation("ProjectMilestones")
  teamMembers         ProjectTeamMember[]  @relation("ProjectTeamMembers")

  @@index([type, status, createdAt])  // プロジェクト一覧取得用
  @@index([projectDueDate])            // 期限ソート・遅延判定用（新規）
  @@index([projectLevel])              // レベル別フィルタリング用（新規）
}
```

##### ProjectMilestoneテーブル（新規）

```prisma
model ProjectMilestone {
  id                String    @id @default(cuid())
  projectId         String    @map("project_id")
  title             String
  description       String?   @db.Text
  dueDate           DateTime  @map("due_date")
  completedAt       DateTime? @map("completed_at")
  completedBy       String?   @map("completed_by")
  status            String    @default("pending") // 'pending' | 'in_progress' | 'completed' | 'cancelled'
  order             Int       @default(0)
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  project           Post      @relation("ProjectMilestones", fields: [projectId], references: [id], onDelete: Cascade)
  completedByUser   User?     @relation("MilestoneCompletedBy", fields: [completedBy], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([status])
  @@index([dueDate])
  @@map("project_milestones")
}
```

##### ProjectTeamMemberテーブル（新規）

```prisma
model ProjectTeamMember {
  id                String    @id @default(cuid())
  projectId         String    @map("project_id")
  userId            String    @map("user_id")
  role              String    @default("member") // 'leader' | 'sub_leader' | 'member' | 'observer'
  joinedAt          DateTime  @default(now()) @map("joined_at")
  leftAt            DateTime? @map("left_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  project           Post      @relation("ProjectTeamMembers", fields: [projectId], references: [id], onDelete: Cascade)
  user              User      @relation("ProjectMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([role])
  @@map("project_team_members")
}
```

##### Userテーブル拡張

```prisma
model User {
  // ... 既存フィールド

  // ProgressDashboard統合実装（2025-10-11）
  projectMemberships      ProjectTeamMember[]   @relation("ProjectMemberships")
  completedMilestones     ProjectMilestone[]    @relation("MilestoneCompletedBy")
}
```

**マイグレーション実行**:
```bash
# スキーマ更新
npx prisma migrate dev --name add_progress_dashboard_tables

# 既存プロジェクトデータ移行
UPDATE "Post"
SET
  "project_due_date" = "createdAt" + INTERVAL '3 months',
  "project_level" = 'team',
  "project_progress" = 0
WHERE "type" = 'project' AND "project_due_date" IS NULL;
```

---

#### タスク2: ProgressDashboardService実装

**実装期間**: 2日
**優先度**: 🔴 HIGH

**実装内容**:

プロジェクト一覧取得・統計計算・マイルストーン管理のサービス層を実装。

```typescript
// src/services/ProgressDashboardService.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ProgressDashboardService {
  /**
   * アクセス可能なプロジェクト一覧取得
   */
  async getAccessibleProjects(userId: string, options: {
    filter?: 'all' | 'active' | 'completed' | 'delayed';
    facilityId?: string;
    departmentId?: string;
    limit?: number;
    offset?: number;
  }) {
    const { filter = 'all', limit = 20, offset = 0 } = options;

    // 1. ユーザー権限取得
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, level: true, facilityId: true, departmentId: true }
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.level < 10) {
      throw new Error('Level 10+ required for ProgressDashboard');
    }

    // 2. WHERE条件構築
    const where: any = { type: 'project' };

    // 2.1 ステータスフィルター
    if (filter === 'active') {
      where.status = 'active';
    } else if (filter === 'completed') {
      where.status = 'completed';
    }

    // 2.2 権限ベースフィルタリング
    if (user.level < 13) {
      // Level 10-12: 自施設のみ
      where.author = {
        facilityId: options.facilityId || user.facilityId
      };

      if (user.level === 10) {
        // Level 10 (部長): 自部門のみ
        where.author = {
          ...where.author,
          departmentId: options.departmentId || user.departmentId
        };
      }
    }
    // Level 13+: 全施設アクセス可能（フィルタなし）

    // 3. プロジェクト取得
    const projects = await prisma.post.findMany({
      where,
      include: {
        author: {
          select: {
            id: true,
            name: true,
            facilityId: true,
            departmentId: true
          }
        },
        milestones: {
          select: {
            id: true,
            status: true
          }
        },
        teamMembers: {
          where: { leftAt: null },
          select: {
            id: true,
            userId: true,
            role: true
          }
        },
        _count: {
          select: {
            milestones: true,
            teamMembers: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: limit
    });

    // 4. 総件数取得
    const totalCount = await prisma.post.count({ where });

    // 5. データ加工（遅延判定・進捗計算）
    const now = new Date();
    const result = projects.map(project => {
      const completedMilestones = project.milestones.filter(m => m.status === 'completed').length;
      const totalMilestones = project.milestones.length;

      // 進捗計算
      const progress = totalMilestones > 0
        ? Math.round((completedMilestones / totalMilestones) * 100)
        : project.projectProgress || 0;

      // 遅延判定
      const isDelayed = project.projectDueDate &&
                       project.projectDueDate < now &&
                       project.status !== 'completed';

      return {
        id: project.id,
        title: project.title || '無題のプロジェクト',
        description: project.content,
        status: project.status,
        progress,
        teamSize: project._count.teamMembers,
        completedMilestones,
        totalMilestones,
        dueDate: project.projectDueDate?.toISOString(),
        isDelayed,
        level: project.projectLevel,
        createdAt: project.createdAt.toISOString()
      };
    });

    // 6. 遅延フィルタリング（必要な場合）
    const filteredResult = filter === 'delayed'
      ? result.filter(p => p.isDelayed)
      : result;

    return {
      projects: filteredResult,
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount
      }
    };
  }

  /**
   * プロジェクト統計取得
   */
  async getProjectStats(userId: string, options: {
    facilityId?: string;
    departmentId?: string;
  }) {
    // ユーザー権限取得
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, level: true, facilityId: true, departmentId: true }
    });

    if (!user || user.level < 10) {
      throw new Error('Insufficient permissions');
    }

    // WHERE条件構築（getAccessibleProjectsと同じロジック）
    const where: any = { type: 'project' };

    if (user.level < 13) {
      where.author = {
        facilityId: options.facilityId || user.facilityId
      };
      if (user.level === 10) {
        where.author = {
          ...where.author,
          departmentId: options.departmentId || user.departmentId
        };
      }
    }

    // 並列クエリで統計取得
    const [total, active, completed, allProjects] = await Promise.all([
      prisma.post.count({ where }),
      prisma.post.count({ where: { ...where, status: 'active' } }),
      prisma.post.count({ where: { ...where, status: 'completed' } }),
      prisma.post.findMany({
        where,
        include: {
          milestones: {
            select: { status: true }
          }
        }
      })
    ]);

    // 遅延判定
    const now = new Date();
    const delayed = allProjects.filter(p =>
      p.projectDueDate && p.projectDueDate < now && p.status !== 'completed'
    ).length;

    // 平均進捗計算
    const avgProgress = allProjects.length > 0
      ? Math.round(
          allProjects.reduce((sum, p) => {
            const completedMilestones = p.milestones.filter(m => m.status === 'completed').length;
            const totalMilestones = p.milestones.length;
            const progress = totalMilestones > 0
              ? (completedMilestones / totalMilestones) * 100
              : p.projectProgress || 0;
            return sum + progress;
          }, 0) / allProjects.length
        )
      : 0;

    return {
      total,
      active,
      completed,
      delayed,
      avgProgress
    };
  }
}
```

**テスト**:
```typescript
// tests/unit/ProgressDashboardService.test.ts

describe('ProgressDashboardService', () => {
  it('getAccessibleProjects - Level 10は自部門のみアクセス可能', async () => {
    const result = await service.getAccessibleProjects('level10-user-001', {
      filter: 'all',
      limit: 10
    });

    // すべてのプロジェクトが自部門のもの
    result.projects.forEach(project => {
      expect(project.author.departmentId).toBe('dept-A');
    });
  });

  it('getProjectStats - 統計計算が正しい', async () => {
    const stats = await service.getProjectStats('level10-user-001', {});

    expect(stats).toHaveProperty('total');
    expect(stats).toHaveProperty('active');
    expect(stats).toHaveProperty('completed');
    expect(stats).toHaveProperty('delayed');
    expect(stats).toHaveProperty('avgProgress');
    expect(stats.avgProgress).toBeGreaterThanOrEqual(0);
    expect(stats.avgProgress).toBeLessThanOrEqual(100);
  });
});
```

---

#### タスク3: API実装（3エンドポイント）

**実装期間**: 1.5日
**優先度**: 🔴 HIGH

**実装内容**:

ProgressDashboard用の3つのAPIエンドポイントを実装。

##### API 1: プロジェクト一覧取得

```typescript
// src/app/api/progress-dashboard/projects/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { ProgressDashboardService } from '@/services/ProgressDashboardService';
import { authenticateUser } from '@/lib/auth';

const service = new ProgressDashboardService();

export async function GET(request: NextRequest) {
  try {
    const user = await authenticateUser(request);
    if (!user) {
      return NextResponse.json(
        { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },
        { status: 401 }
      );
    }

    // Level 10+チェック
    if (user.level < 10) {
      return NextResponse.json(
        {
          error: {
            code: 'FORBIDDEN',
            message: 'このページは部長以上のみアクセス可能です',
            details: `User level: ${user.level}, Required: 10+`
          }
        },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const filter = searchParams.get('filter') as 'all' | 'active' | 'completed' | 'delayed' | undefined;
    const facilityId = searchParams.get('facilityId') || undefined;
    const departmentId = searchParams.get('departmentId') || undefined;
    const limit = parseInt(searchParams.get('limit') || '20', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    const result = await service.getAccessibleProjects(user.id, {
      filter,
      facilityId,
      departmentId,
      limit,
      offset
    });

    return NextResponse.json({
      data: result.projects,
      pagination: result.pagination,
      meta: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('GET /api/progress-dashboard/projects error:', error);
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch projects',
          details: error.message
        }
      },
      { status: 500 }
    );
  }
}
```

##### API 2: 統計サマリー取得

```typescript
// src/app/api/progress-dashboard/stats/route.ts
// （API 1と同様の構造、service.getProjectStatsを呼び出し）
```

##### API 3: マイルストーン一覧取得

```typescript
// src/app/api/progress-dashboard/projects/[projectId]/milestones/route.ts
// （プロジェクトIDからマイルストーン一覧を取得）
```

**APIテスト**:
```bash
# プロジェクト一覧取得
curl -X GET "http://localhost:3000/api/progress-dashboard/projects?filter=all&limit=10" \
  -H "Authorization: Bearer $LEVEL10_TOKEN"

# 統計サマリー取得
curl -X GET "http://localhost:3000/api/progress-dashboard/stats" \
  -H "Authorization: Bearer $LEVEL10_TOKEN"
```

---

#### タスク4: フロントエンド実装（オプション）

**実装期間**: 2日
**優先度**: 🟡 MEDIUM（VoiceDrive側で実装済みの可能性）

**実装内容**:

useProgressDashboardフックとProgressDashboardページコンポーネント。

```typescript
// src/hooks/useProgressDashboard.ts

import useSWR from 'swr';

export function useProgressDashboard(
  filter: 'all' | 'active' | 'completed' | 'delayed',
  options?: {
    facilityId?: string;
    departmentId?: string;
  }
) {
  const queryParams = new URLSearchParams({
    filter,
    ...(options?.facilityId && { facilityId: options.facilityId }),
    ...(options?.departmentId && { departmentId: options.departmentId })
  });

  const { data: projectsData, error: projectsError, isLoading: projectsLoading } = useSWR(
    `/api/progress-dashboard/projects?${queryParams.toString()}`
  );

  const { data: statsData, error: statsError, isLoading: statsLoading } = useSWR(
    `/api/progress-dashboard/stats?${queryParams.toString()}`,
    { refreshInterval: 60000 }
  );

  return {
    projects: projectsData?.data || [],
    pagination: projectsData?.pagination,
    stats: statsData?.data,
    isLoading: projectsLoading || statsLoading,
    error: projectsError || statsError
  };
}
```

---

#### VoiceDrive実装スケジュール（ProgressDashboard）

| タスク | 実装期間 | 優先度 | 備考 |
|--------|---------|--------|------|
| **タスク1**: データベース構築 | 1.5日 | 🔴 HIGH | ProjectTracking後、2新規テーブル + Post拡張 |
| **タスク2**: ProgressDashboardService | 2日 | 🔴 HIGH | 権限ベースフィルタリング必須 |
| **タスク3**: API実装（3エンドポイント） | 1.5日 | 🔴 HIGH | Level 10+チェック、エラーハンドリング |
| **タスク4**: フロントエンド実装 | 2日 | 🟡 MEDIUM | オプション（既存実装確認） |
| **テスト・デバッグ** | 2日 | 🔴 HIGH | 権限テスト、パフォーマンステスト |

**合計**: 9日（共通DB構築後に実施、ProjectTracking実装後）

**テスト要件**:
- ユニットテスト: 15ケース以上（遅延判定、進捗計算、権限チェック）
- API統合テスト: 12ケース以上（3エンドポイント × 4ケース）
- 権限テスト: Level 10/13での動作確認（必須）
- パフォーマンステスト: 1,000プロジェクトでの一覧取得速度（< 500ms）

**医療システムAPIの利用**: 既存APIのみ使用
- GET /api/v2/facilities - 施設マスター取得
- GET /api/v2/departments - 部門マスター取得
- GET /api/v2/employees/{id} - 職員情報取得

**特記事項**:
- ⚠️ Level 10（部長）は自部門のみアクセス可能
- ⚠️ Level 13+（理事）は全施設アクセス可能
- ✅ 進捗計算はマイルストーン完了率から自動算出
- 📊 遅延判定は期限日時 < 現在日時 && status !== 'completed'

---

### 6.4 Strategic HR Plan API統合テスト

**前提条件**:
- ⏳ Phase 1実装予定（2025年10月21日〜11月1日）
- ⏳ 単体テスト予定（モックデータ）
- ✅ 実装方針確定済み（MED-CONF-2025-1010-013）
- ✅ VoiceDrive回答書受領済み（VD-A-2025-1010-012）

#### 6.4.1 Phase分割戦略

**Phase 1: 戦略的人事計画タブ（推定6日、10/21-11/1）**
- DB: 3テーブル（StrategicHRGoal, StrategicInitiative, HRStrategyRoadmap）
- API: 4エンドポイント
- スコープ外: パフォーマンス分析、組織健全性指標、退職理由分析

**Phase 2: 組織開発・パフォーマンス分析（推定6.5日、12月中旬〜1月上旬）**
- DB: 5テーブル（OrganizationHealthMetrics, PerformanceAnalytics, ImprovementProposal等）
- API: 5エンドポイント
- VoiceDrive活動データ統合開始

**Phase 3: 退職管理・高度分析（推定3.5日、2026年1月下旬〜2月上旬）**
- DB: 5テーブル（RetirementProcess, InfluenceAnalysis等）
- API: 3エンドポイント
- 影響力分析の実データ表示

#### 6.4.2 環境変数設定

```bash
# .env.productionに追加
STRATEGIC_HR_API_KEY=[openssl rand -hex 32で生成したAPI Key]

# VoiceDrive側の設定確認（VoiceDriveチームに共有）
# MEDICAL_SYSTEM_STRATEGIC_HR_URL=https://medical.example.com/api/v2/strategic-hr
# MEDICAL_SYSTEM_STRATEGIC_HR_KEY=[上記のSTRATEGIC_HR_API_KEYと同じ値]
```

**API Key生成方法**:
```bash
# ランダムなAPI Keyを生成
openssl rand -hex 32

# 生成されたAPI Keyを.env.productionとVoiceDriveチームに共有
```

#### 6.4.3 Phase 1実データでAPI動作確認

```bash
# API-1: 戦略的人事目標取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024&facilityId=facility-001" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": {
#     "fiscalYear": 2024,
#     "facilityId": "facility-001",
#     "employeeSatisfactionTarget": 85.0,
#     "employeeSatisfactionCurrent": 82.3,
#     "turnoverRateTarget": 8.5,
#     "turnoverRateCurrent": 9.2,
#     "annualHiringTarget": 15,
#     "annualHiringCurrent": 12
#   },
#   "meta": {
#     "timestamp": "2025-10-21T12:00:00.000Z"
#   }
# }

# API-2: 戦略的イニシアチブ取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/initiatives?facilityId=facility-001&status=in_progress" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 期待されるレスポンス:
# {
#   "data": [
#     {
#       "id": "init-001",
#       "name": "メンター制度導入",
#       "description": "新人看護師向けメンター制度の導入",
#       "category": "人材育成",
#       "progressPercent": 65.0,
#       "deadline": "2024-12-31",
#       "priority": "high",
#       "status": "in_progress"
#     }
#   ],
#   "meta": {
#     "total": 5,
#     "timestamp": "2025-10-21T12:00:00.000Z"
#   }
# }

# API-3: 人材戦略ロードマップ取得テスト
curl -X GET "http://localhost:3000/api/v2/strategic-hr/roadmap?facilityId=facility-001" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# API-4: 退職統計取得テスト
curl -X GET "http://localhost:3000/api/v2/retirement/statistics?facilityId=facility-001&fiscalYear=2024" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}"

# 注意: Phase 1では基本統計のみ、Phase 3で詳細な退職理由分析を実装
```

#### 6.4.4 エラーハンドリングテスト

```bash
# 401 Unauthorized（API Key未提供）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"API Key is required"}}

# 401 Unauthorized（不正なAPI Key）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
  -H "X-API-Key: invalid-key"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"Invalid API Key"}}

# 403 Forbidden（権限不足）
curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
  -H "X-API-Key: ${STRATEGIC_HR_API_KEY}" \
  -H "X-User-Permission-Level: 10"
# 期待: {"error":{"code":"FORBIDDEN","message":"Level 16+ required"}}

# 429 Rate Limit超過テスト（100回超過でエラー）
for i in {1..105}; do
  curl -X GET "http://localhost:3000/api/v2/strategic-hr/goals?fiscalYear=2024" \
    -H "X-API-Key: ${STRATEGIC_HR_API_KEY}" \
    -H "X-Forwarded-For: 192.168.1.200"
done
# 101回目以降: {"error":{"code":"RATE_LIMIT_EXCEEDED","message":"Too many requests"}}
```

#### 6.4.5 VoiceDriveチームとの統合テスト

```bash
# VoiceDriveチームに以下を共有:
# - APIエンドポイントURL: https://medical.example.com/api/v2/strategic-hr
# - VoiceDrive用APIキー: [Slackで共有]
# - 実装方針確定書: mcp-shared/docs/strategic-hr-plan_実装方針確定書_20251010.md

# VoiceDriveチーム側での確認事項:
# 1. StrategicHRServiceでAPIを呼び出し（Phase 1: 4エンドポイント）
# 2. StrategicHRPageの戦略的人事計画タブが実データで表示
# 3. Level 16権限チェックが正常動作
# 4. 施設フィルタリング（Level 18用）が動作
```

#### 6.4.6 Phase 1統合テスト完了基準
- [ ] API-1（戦略的人事目標）が実データで正常動作
- [ ] API-2（戦略的イニシアチブ）が実データで正常動作
- [ ] API-3（人材戦略ロードマップ）が実データで正常動作
- [ ] API-4（退職統計）が実データで正常動作
- [ ] Rate Limitヘッダーが正常に返却される
- [ ] エラーレスポンスが仕様通り
- [ ] VoiceDrive StrategicHRPageの戦略的人事計画タブで表示確認
- [ ] Level 16権限チェック動作確認
- [ ] 施設フィルタリング動作確認（Level 18用）

**推定工数**: Phase 1統合テスト 2日間（DB構築後）

**関連ドキュメント**:
- 実装方針確定書: `mcp-shared/docs/strategic-hr-plan_実装方針確定書_20251010.md`
- VoiceDrive回答書: `mcp-shared/docs/strategic-hr-plan_VoiceDrive回答書_20251010.md`
- DB要件分析: `mcp-shared/docs/strategic-hr-plan_DB要件分析_20251010.md`
- テーブル設計承認依頼: `mcp-shared/docs/strategic-hr-plan_テーブル設計承認依頼_20251010.md`

**実装予定ファイル（Phase 1）**:
- `src/app/api/v2/strategic-hr/goals/route.ts` - 戦略的人事目標API
- `src/app/api/v2/strategic-hr/initiatives/route.ts` - 戦略的イニシアチブAPI
- `src/app/api/v2/strategic-hr/roadmap/route.ts` - 人材戦略ロードマップAPI
- `src/app/api/v2/retirement/statistics/route.ts` - 退職統計API
- テストファイル4件（Phase 1単体テスト）

#### 6.4.7 Phase 2/3統合テスト（将来実装）

**Phase 2統合テスト（12月中旬〜1月上旬予定）**:
- 組織健全性指標API統合テスト
- パフォーマンス分析API統合テスト
- 改善提案実績API統合テスト
- VoiceDrive活動データ統合テスト

**Phase 3統合テスト（2026年1月下旬〜2月上旬予定）**:
- 退職プロセスAPI統合テスト
- 退職理由分析API統合テスト
- 影響力分析API統合テスト

---

## 6.5 Phase X: 組織構造マスター統合実装

**実装タイミング**: 共通DB構築完了後
**実装期間**: 2週間（10営業日）
**担当**: 医療システムチーム + VoiceDriveチーム
**重要度**: 🔴 HIGH
**承認日**: 2025年10月12日
**承認文書**: `mcp-shared/docs/組織構造拡張実装_マスタープラン統合回答書_20251012.md`

### 6.5.1 実装概要

VoiceDriveの議題モード・プロジェクトモードにおいて、病院組織構造に基づく柔軟な投票スコープ管理を実装します。

**実装方針**:
- 組織マスターデータは医療システムが管理（Single Source of Truth）
- VoiceDriveはAPI経由でデータ取得し、キャッシュ + 投票ルール管理
- 両システム同時実装により整合性確保

### 6.5.2 医療システム側実装（3営業日）

#### タスク一覧

| タスク | 工数 | 担当 | 優先度 |
|--------|------|------|--------|
| **組織マスターテーブル設計** | 0.5日 | DBチーム | 🔴 HIGH |
| **施設マスターAPI実装** | 1日 | バックエンドチーム | 🔴 HIGH |
| **組織構造マスターAPI実装** | 1日 | バックエンドチーム | 🔴 HIGH |
| **職種マスターAPI実装** | 0.5日 | バックエンドチーム | 🔴 HIGH |

#### 実装API

```typescript
// 施設マスターAPI
GET /api/v2/facilities              // 施設一覧
GET /api/v2/facilities/{id}         // 施設詳細

// 組織構造マスターAPI
GET /api/v2/departments             // 部門一覧
GET /api/v2/departments/{id}        // 部門詳細
GET /api/v2/departments/{id}/members // 部門所属職員

// 職種マスターAPI
GET /api/v2/job-categories          // 職種マスター一覧
```

#### テーブル設計

```sql
-- 施設マスター
CREATE TABLE facilities (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  facility_type VARCHAR(50),
  staff_count INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 組織構造マスター
CREATE TABLE organization_structures (
  id VARCHAR(50) PRIMARY KEY,
  facility_id VARCHAR(50) REFERENCES facilities(id),
  name VARCHAR(200) NOT NULL,
  code VARCHAR(50) NOT NULL,
  type VARCHAR(50),  -- clinical/administrative/support
  parent_id VARCHAR(50),
  staff_count INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(facility_id, code)
);

-- 職種マスター
CREATE TABLE job_categories (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  code VARCHAR(50) NOT NULL UNIQUE,
  category VARCHAR(50),  -- nursing/rehabilitation/medical/admin
  requires_license BOOLEAN DEFAULT false,
  license_type VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6.5.3 VoiceDrive側実装（5営業日）

#### タスク一覧

| タスク | 工数 | 担当 | 優先度 |
|--------|------|------|--------|
| **Prismaスキーマ拡張** | 0.5日 | VoiceDriveチーム | 🔴 HIGH |
| **マイグレーション実行** | 0.5日 | VoiceDriveチーム | 🔴 HIGH |
| **シードデータ投入** | 1日 | VoiceDriveチーム | 🔴 HIGH |
| **投票スコープロジック実装** | 2日 | VoiceDriveチーム | 🔴 HIGH |
| **医療システムAPI連携** | 1日 | VoiceDriveチーム | 🔴 HIGH |

#### 実装内容
- VoiceDrive Prismaスキーマに8テーブル追加（準備済み）
- 投票スコープパターン実装（A: location_based, B: profession_based, C: department_based）
- 医療システムAPIクライアント実装
- 日次バッチ同期機能実装

### 6.5.4 統合テスト（2営業日）

| テスト項目 | 工数 | 担当 | 優先度 |
|-----------|------|------|--------|
| **API連携テスト** | 0.5日 | 両チーム | 🔴 HIGH |
| **データ同期テスト** | 0.5日 | 両チーム | 🔴 HIGH |
| **投票スコープテスト** | 0.5日 | VoiceDriveチーム | 🔴 HIGH |
| **エンドツーエンドテスト** | 0.5日 | 両チーム | 🔴 HIGH |

### 6.5.5 実装データ詳細

#### 施設情報（3施設・確定）

| 施設コード | 施設名 | 種別 | 職員数 | 部門数 |
|-----------|--------|------|--------|--------|
| `obara-hospital` | 小原病院 | 急性期病院 | 約80名 | 10部門 |
| `tategami-rehabilitation` | 立神リハビリテーション温泉病院 | 回復期リハビリ病院 | 約100名 | 7部門 |
| `espoir-tategami` | 介護老人保健施設エスポワール立神 | 老健施設 | 約150名 | 6部門 |

#### 投票スコープパターン（確定）

| パターン | コード | 適用部門 | 説明 |
|---------|--------|---------|------|
| **A** | `location_based` | 看護部門 | 病棟・外来単位での投票 |
| **B** | `profession_based` | リハビリ部門 | 職種単位での投票（PT/OT/ST） |
| **C** | `department_based` | 小規模部門 | 部門全体での投票 |

#### 新規職種（5職種追加）

| 職種コード | 職種名 | 資格要否 | 該当施設 |
|-----------|--------|---------|---------|
| `care_manager` | ケアマネージャー | 必要（介護支援専門員） | エスポワール立神 |
| `social_worker` | 社会福祉士 | 必要（社会福祉士） | エスポワール立神 |
| `certified_care_worker` | 介護福祉士 | 必要（国家資格） | エスポワール立神 |
| `registered_dietitian` | 管理栄養士 | 必要（国家資格） | 全施設 |
| `dietitian` | 栄養士 | 必要（都道府県資格） | 全施設 |

### 6.5.6 実装スケジュール

```
Week 1（共通DB構築完了後）:
  Day 1-2: 医療システム側DB設計・テーブル作成
  Day 3-4: 医療システム側API実装
  Day 5: 医療システム側API動作確認

Week 2:
  Day 1: VoiceDrive側マイグレーション実行
  Day 2: VoiceDrive側シードデータ投入
  Day 3-4: VoiceDrive側投票ロジック実装
  Day 5: VoiceDrive側医療システムAPI連携実装

Week 3（統合テスト・デプロイ）:
  Day 1-2: 統合テスト実施
  Day 3: 本番環境デプロイ準備
  Day 4: 本番環境デプロイ実施
  Day 5: 本番環境監視・調整
```

### 6.5.7 成功基準

- [ ] 3施設（小原病院・立神リハビリ・エスポワール立神）のデータ正常登録
- [ ] 23部門のデータ正常登録
- [ ] 24職種（新規5職種含む）のデータ正常登録
- [ ] 投票スコープパターンA/B/C動作確認
- [ ] 医療システムからの組織変更反映テスト成功（Webhook経由）
- [ ] API応答時間 < 200ms
- [ ] データ整合性チェック成功

### 6.5.8 監視・運用

**監視項目**:
- API応答時間
- データ同期エラー率
- Webhook送信成功率
- 投票スコープ判定エラー

**運用手順**:
1. 日次バッチによる組織データ同期（深夜2:00 JST）
2. Webhookによる組織変更即時反映
3. 週次での整合性チェック（日曜深夜）

### 6.5.9 関連ドキュメント

- 組織情報提供書: `mcp-shared/docs/組織情報収集依頼_医療システム返信書_20251012.md`
- マスタープラン統合回答書: `mcp-shared/docs/組織構造拡張実装_マスタープラン統合回答書_20251012.md`
- 投票グループ承認者機能確認: `mcp-shared/docs/投票グループ承認者機能_医療システム確認回答_20251012.md`
- 医療システム質問回答書: `mcp-shared/docs/医療システム質問_VoiceDrive回答書_20251012.md`
- データ管理責任分界点定義書: `mcp-shared/docs/データ管理責任分界点定義書_20251008.md`

---

### 6.6 Phase 3: 委員会マスタAPI実装（ProposalDocument連携）

**実装時期**: 2025年11月8日（金）〜11月15日（金）（8日間）
**優先度**: 🟡 中優先度
**参照文書**: `mcp-shared/docs/ProposalDocument_医療システム確認結果_20251021.md`

#### 6.6.1 実装概要

VoiceDrive側の議題提案書編集ページ（ProposalDocumentEditor）で委員会一覧を取得するためのAPI実装。

**データ管理責任**:
- 委員会マスタ: ✅ 医療システム管轄
- 議題提案書データ: ❌ VoiceDrive 100%管轄

#### 6.6.2 DB実装（Day 1-2）

**新規テーブル作成**:

```prisma
// prisma/schema.prisma

// 委員会マスタ
model Committee {
  id              String   @id @default(cuid())
  code            String   @unique
  name            String
  type            String   // operational, management, corporate
  level           String   // department, facility, corporate
  facilityId      String?  // 施設レベルの場合
  description     String?
  chairpersonId   String   // 委員長のemployeeId
  meetingCycle    String   // monthly, quarterly, yearly
  nextMeetingDate DateTime?
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  facility        Facility? @relation(fields: [facilityId], references: [id])
  members         CommitteeMember[]

  @@index([facilityId])
  @@index([level])
  @@index([type])
  @@map("committees")
}

// 委員会メンバー
model CommitteeMember {
  id          String   @id @default(cuid())
  committeeId String
  employeeId  String
  role        String   // chairperson, vice_chairperson, member, secretary
  joinedDate  DateTime @default(now())
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  committee   Committee @relation(fields: [committeeId], references: [id])

  @@unique([committeeId, employeeId])
  @@index([employeeId])
  @@map("committee_members")
}
```

**マイグレーション実行**:
```bash
# Day 1: スキーマ作成
npx prisma migrate dev --name add_committee_tables

# Day 2: 本番環境マイグレーション
npx prisma migrate deploy
```

#### 6.6.3 テストデータ投入（Day 2）

**小原病院の委員会データ**:
```javascript
// scripts/seed-committees.ts
const committees = [
  {
    code: 'OH-COM-001',
    name: '業務改善委員会',
    type: 'operational',
    level: 'facility',
    facilityId: 'obara-hospital',
    description: '施設運営の業務改善に関する審議',
    chairpersonId: 'OH-NS-2024-030', // 山田事務長
    meetingCycle: 'monthly',
    nextMeetingDate: new Date('2025-11-10T14:00:00Z')
  },
  {
    code: 'OH-COM-002',
    name: '施設運営委員会',
    type: 'management',
    level: 'facility',
    facilityId: 'obara-hospital',
    description: '施設全体の運営方針に関する審議',
    chairpersonId: 'OH-NS-2024-040', // 佐藤院長
    meetingCycle: 'monthly',
    nextMeetingDate: new Date('2025-11-15T10:00:00Z')
  },
  {
    code: 'CORP-COM-001',
    name: '法人運営委員会',
    type: 'corporate',
    level: 'corporate',
    chairpersonId: 'CORP-2024-001', // 理事長
    meetingCycle: 'quarterly',
    nextMeetingDate: new Date('2025-12-20T13:00:00Z')
  }
];
```

**実行コマンド**:
```bash
npx tsx scripts/seed-committees.ts
```

#### 6.6.4 API実装（Day 3-4）

**エンドポイント**: `GET /api/v2/committees`

**実装ファイル**: `src/app/api/v2/committees/route.ts`（新規作成）

```typescript
// src/app/api/v2/committees/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const level = searchParams.get('level');
    const facilityId = searchParams.get('facilityId');
    const type = searchParams.get('type');
    const userId = searchParams.get('userId');
    const userLevel = parseInt(searchParams.get('userLevel') || '1');

    // 権限チェック
    if (userLevel < 5) {
      return NextResponse.json({
        success: false,
        error: '委員会情報の閲覧には Level 5 以上の権限が必要です'
      }, { status: 403 });
    }

    // フィルタ構築
    const where: any = { isActive: true };

    if (level) where.level = level;
    if (type) where.type = type;

    // Level別フィルタリング
    if (userLevel >= 14) {
      // Level 14+: 法人全体
      if (facilityId) where.facilityId = facilityId;
    } else if (userLevel >= 10) {
      // Level 10+: 所属施設のみ
      const user = await prisma.employee.findUnique({ where: { id: userId } });
      where.facilityId = user?.facilityId;
    } else {
      // Level 5-9: 自分が所属する委員会のみ
      where.members = { some: { employeeId: userId, isActive: true } };
    }

    // 委員会取得
    const committees = await prisma.committee.findMany({
      where,
      include: {
        facility: { select: { id: true, name: true, code: true } },
        members: {
          where: { isActive: true },
          include: {
            employee: {
              select: { id: true, name: true, positionId: true }
            }
          }
        }
      },
      orderBy: { level: 'asc' }
    });

    // レスポンス整形
    const response = committees.map(c => ({
      id: c.id,
      code: c.code,
      name: c.name,
      type: c.type,
      level: c.level,
      facilityId: c.facilityId,
      facilityName: c.facility?.name,
      description: c.description,
      chairperson: {
        id: c.chairpersonId,
        // 委員長情報はmembersから取得
        name: c.members.find(m => m.role === 'chairperson')?.employee.name || '',
        position: c.members.find(m => m.role === 'chairperson')?.employee.positionId || ''
      },
      members: c.members.map(m => ({
        id: m.employee.id,
        name: m.employee.name,
        role: m.role
      })),
      meetingCycle: c.meetingCycle,
      nextMeetingDate: c.nextMeetingDate
    }));

    return NextResponse.json({
      success: true,
      committees: response,
      total: response.length
    });
  } catch (error) {
    console.error('委員会マスタAPI Error:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

#### 6.6.5 単体テスト（Day 5）

**テストファイル**: `tests/api/v2/committees.test.ts`（新規作成）

```typescript
// tests/api/v2/committees.test.ts
import { describe, it, expect } from '@jest/globals';

describe('GET /api/v2/committees', () => {
  it('正常系: 全委員会取得（Level 14+）', async () => {
    const response = await fetch('/api/v2/committees?userId=CORP-2024-001&userLevel=14');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.committees).toHaveLength(3);
  });

  it('正常系: 施設別フィルタ', async () => {
    const response = await fetch('/api/v2/committees?facilityId=obara-hospital&userId=OH-NS-2024-040&userLevel=12');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.committees).toHaveLength(2); // 業務改善、施設運営
  });

  it('正常系: タイプ別フィルタ', async () => {
    const response = await fetch('/api/v2/committees?type=corporate&userId=CORP-2024-001&userLevel=14');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.committees).toHaveLength(1); // 法人運営
  });

  it('正常系: Level 10-13は所属施設のみ', async () => {
    const response = await fetch('/api/v2/committees?userId=OH-NS-2024-030&userLevel=10');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.committees.every(c => c.facilityId === 'obara-hospital')).toBe(true);
  });

  it('正常系: Level 5-9は所属委員会のみ', async () => {
    const response = await fetch('/api/v2/committees?userId=OH-NS-2024-015&userLevel=7');
    const data = await response.json();

    expect(data.success).toBe(true);
    // メンバーとして登録されている委員会のみ表示
  });

  it('異常系: Level 4以下は403エラー', async () => {
    const response = await fetch('/api/v2/committees?userId=OH-NS-2024-005&userLevel=4');

    expect(response.status).toBe(403);
    const data = await response.json();
    expect(data.success).toBe(false);
  });
});
```

**実行コマンド**:
```bash
npm run test -- tests/api/v2/committees.test.ts
```

#### 6.6.6 VoiceDrive統合テスト（Day 6）

**VoiceDrive側の使用例**:
```typescript
// VoiceDrive: src/services/CommitteeService.ts
async fetchCommittees(userId: string, userLevel: number) {
  const response = await fetch(
    `${MEDICAL_SYSTEM_API_URL}/api/v2/committees?userId=${userId}&userLevel=${userLevel}`
  );
  const data = await response.json();
  return data.committees;
}
```

**統合テストシナリオ**:
1. VoiceDrive側から医療システムAPIを呼び出し
2. 委員会一覧を取得
3. ProposalDocumentEditorの提出先選択UIに表示
4. 委員長・メンバー情報の表示確認

#### 6.6.7 実装スケジュール

| 日付 | 作業内容 | 担当 | 状態 |
|------|---------|------|------|
| **11/8（金）** | DB設計レビュー | 医療チーム | ⏳ 提案中 |
| **11/11（月）** | Prismaマイグレーション実施 | 医療チーム | ⏳ 提案中 |
| **11/12（火）** | テストデータ投入 | 医療チーム | ⏳ 提案中 |
| **11/13（水）** | API実装 | 医療チーム | ⏳ 提案中 |
| **11/14（木）** | 単体テスト | 医療チーム | ⏳ 提案中 |
| **11/15（金）** | VoiceDrive統合テスト | 両チーム | ⏳ 提案中 |

#### 6.6.8 成功基準

- ✅ Committeeテーブル作成完了
- ✅ CommitteeMemberテーブル作成完了
- ✅ テストデータ投入完了（最低3委員会）
- ✅ `GET /api/v2/committees` API実装完了
- ✅ 単体テスト7件全て成功
- ✅ VoiceDrive側からのAPI呼び出し成功
- ✅ ProposalDocumentEditorでの委員会選択動作確認

#### 6.6.9 関連ドキュメント

- 医療システム確認結果: `mcp-shared/docs/ProposalDocument_医療システム確認結果_20251021.md`
- VoiceDrive DB要件分析: 提供待ち（PDE-DB-2025-1021-001）
- データ管理責任分界点定義書: `mcp-shared/docs/データ管理責任分界点定義書_20251008.md`

---

### 6.7 Phase 7: キャリアコース変更申請機能（Career Course Change Request）

**実装時期**: 共通DB構築後（予定：2025年12月-2026年1月）
**優先度**: 🔴 **CRITICAL**（人事制度の中核機能）
**参照文書**: `mcp-shared/docs/career-course-change_医療システム確認結果_20251021.md`

#### 6.7.1 実装概要

VoiceDrive側の「コース変更申請ページ」で、職員がキャリアコース（A/B/C/D）の変更を申請するための機能。

**データ管理責任**:
- コース定義マスタ: ✅ 医療システム 100%管轄
- 現在のコース選択状況: ✅ 医療システム 100%管轄
- コース変更申請データ: ✅ 医療システム 100%管轄
- 添付ファイル: ✅ 医療システム 100%管轄（S3/CloudFront）
- VoiceDrive: ❌ UIのみ（データ管理なし）

#### 6.7.2 DB実装（Week 1: Day 1-2）

**新規テーブル作成（3テーブル）**:

```prisma
// prisma/schema.prisma

// コース定義マスタ
model CareerCourseDefinition {
  id                           String  @id @default(cuid())
  courseCode                   String  @unique // 'A', 'B', 'C', 'D'
  courseName                   String
  description                  String?
  departmentTransferAvailable  Boolean @default(true)
  facilityTransferAvailable    String  @default("none") // 'none', 'limited', 'full'
  relocationRequired           Boolean @default(false)
  nightShiftAvailable          String  @default("none") // 'none', 'selectable', 'required'
  managementTrack              Boolean @default(false)
  baseSalaryMultiplier         Float   @default(1.0)
  salaryGrade                  Int?
  salaryNotes                  String?
  isActive                     Boolean @default(true)
  displayOrder                 Int     @default(0)
  createdAt                    DateTime @default(now())
  updatedAt                    DateTime @updatedAt

  selections                   CareerCourseSelection[]
  requestsAsCurrent            CareerCourseChangeRequest[] @relation("CurrentCourse")
  requestsAsRequested          CareerCourseChangeRequest[] @relation("RequestedCourse")

  @@index([courseCode])
  @@index([isActive])
  @@map("career_course_definitions")
}

// 現在のコース選択状況
model CareerCourseSelection {
  id                        String    @id @default(cuid())
  employeeId                String
  courseCode                String
  effectiveFrom             DateTime
  effectiveTo               DateTime?
  nextChangeAvailableDate   DateTime?
  specialChangeReason       String?   // 'pregnancy', 'caregiving', 'illness'
  specialChangeNote         String?
  changeRequestedAt         DateTime?
  changeRequestedBy         String?
  approvedAt                DateTime?
  approvedBy                String?
  approvalStatus            String    @default("approved") // 'pending', 'approved', 'rejected', 'withdrawn'
  rejectionReason           String?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt

  employee        Employee                 @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  courseDefinition CareerCourseDefinition @relation(fields: [courseCode], references: [courseCode])
  approver         Employee?               @relation("CourseApprover", fields: [approvedBy], references: [id])

  @@index([employeeId])
  @@index([courseCode])
  @@index([effectiveFrom, effectiveTo])
  @@index([approvalStatus])
  @@map("career_course_selections")
}

// コース変更申請
model CareerCourseChangeRequest {
  id                       String    @id @default(cuid())
  employeeId               String
  currentCourseCode        String
  requestedCourseCode      String
  changeReason             String    // 'annual', 'special_pregnancy', 'special_caregiving', 'special_illness'
  reasonDetail             String
  requestedEffectiveDate   DateTime
  hrReviewerId             String?
  hrReviewerName           String?
  reviewedAt               DateTime?
  reviewComment            String?
  approvalStatus           String    @default("pending") // 'pending', 'approved', 'rejected', 'withdrawn'
  rejectionReason          String?
  withdrawnAt              DateTime?
  attachments              Json?     // [{"fileUrl": "...", "fileName": "...", "fileSize": 123, "uploadedAt": "..."}]
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  employee          Employee                @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  currentCourse     CareerCourseDefinition  @relation("CurrentCourse", fields: [currentCourseCode], references: [courseCode])
  requestedCourse   CareerCourseDefinition  @relation("RequestedCourse", fields: [requestedCourseCode], references: [courseCode])
  hrReviewer        Employee?               @relation("HRReviewer", fields: [hrReviewerId], references: [id])

  @@index([employeeId])
  @@index([approvalStatus])
  @@index([createdAt(sort: Desc)])
  @@map("career_course_change_requests")
}

// Employeeモデルにリレーション追加
model Employee {
  // ... 既存フィールド ...

  // キャリアコース関連（追加）
  careerCourseSelections    CareerCourseSelection[]
  careerCourseApprovals     CareerCourseSelection[] @relation("CourseApprover")
  careerCourseChangeRequests CareerCourseChangeRequest[]
  careerCourseHRReviews     CareerCourseChangeRequest[] @relation("HRReviewer")
}
```

**マイグレーション実行**:
```bash
# Day 1-2: スキーマ作成
npx prisma migrate dev --name add_career_course_tables

# 本番環境マイグレーション
npx prisma migrate deploy
```

#### 6.7.3 初期データ投入（Week 1: Day 2）

**A/B/C/Dコース定義データ**:

```typescript
// scripts/seed-career-courses.ts
const courseDefinitions = [
  {
    courseCode: 'A',
    courseName: 'Aコース（全面協力型）',
    description: '施設間異動・転居あり、管理職登用対象',
    departmentTransferAvailable: true,
    facilityTransferAvailable: 'full',
    relocationRequired: true,
    nightShiftAvailable: 'required',
    managementTrack: true,
    baseSalaryMultiplier: 1.2,
    salaryGrade: 5,
    salaryNotes: '基本給1.2倍、役職手当別途',
    isActive: true,
    displayOrder: 1
  },
  {
    courseCode: 'B',
    courseName: 'Bコース（施設内協力型）',
    description: '施設内異動可、転居なし',
    departmentTransferAvailable: true,
    facilityTransferAvailable: 'limited',
    relocationRequired: false,
    nightShiftAvailable: 'selectable',
    managementTrack: true,
    baseSalaryMultiplier: 1.1,
    salaryGrade: 4,
    salaryNotes: '基本給1.1倍',
    isActive: true,
    displayOrder: 2
  },
  {
    courseCode: 'C',
    courseName: 'Cコース（専門職型）',
    description: '部署固定、専門性重視',
    departmentTransferAvailable: false,
    facilityTransferAvailable: 'none',
    relocationRequired: false,
    nightShiftAvailable: 'selectable',
    managementTrack: false,
    baseSalaryMultiplier: 1.05,
    salaryGrade: 3,
    salaryNotes: '基本給1.05倍',
    isActive: true,
    displayOrder: 3
  },
  {
    courseCode: 'D',
    courseName: 'Dコース（時短・制約あり型）',
    description: '時短勤務、夜勤なし',
    departmentTransferAvailable: false,
    facilityTransferAvailable: 'none',
    relocationRequired: false,
    nightShiftAvailable: 'none',
    managementTrack: false,
    baseSalaryMultiplier: 1.0,
    salaryGrade: 2,
    salaryNotes: '基本給通常',
    isActive: true,
    displayOrder: 4
  }
];
```

**実行コマンド**:
```bash
npx tsx scripts/seed-career-courses.ts
```

#### 6.7.4 API実装（Week 1: Day 3-4）

**API-1: コース定義一覧取得**

**エンドポイント**: `GET /api/career-courses/definitions`

**実装ファイル**: `src/app/api/career-courses/definitions/route.ts`（新規作成）

```typescript
// src/app/api/career-courses/definitions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const courses = await prisma.careerCourseDefinition.findMany({
      where: { isActive: true },
      orderBy: { displayOrder: 'asc' }
    });

    return NextResponse.json({
      success: true,
      courses
    });
  } catch (error) {
    console.error('コース定義取得エラー:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

**API-2: マイページ情報取得（現在のコース含む）**

**エンドポイント**: `GET /api/my-page`（既存APIに拡張）

```typescript
// src/app/api/my-page/route.ts に追加
export async function GET(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');

    const employee = await prisma.employee.findUnique({
      where: { id: userId },
      include: {
        department: true,
        position: true,
        facility: true
      }
    });

    // 現在のコース取得（追加）
    const currentCourse = await prisma.careerCourseSelection.findFirst({
      where: {
        employeeId: userId,
        effectiveTo: null  // 現在有効なコース
      },
      include: {
        courseDefinition: true
      }
    });

    return NextResponse.json({
      id: employee.id,
      name: employee.name,
      position: employee.position.name,
      department: employee.department.name,
      facility: employee.facility.name,
      employeeId: employee.employeeCode,
      joinDate: employee.hireDate,
      careerCourse: currentCourse ? {
        courseCode: currentCourse.courseCode,
        courseName: currentCourse.courseDefinition.courseName,
        effectiveFrom: currentCourse.effectiveFrom,
        effectiveTo: currentCourse.effectiveTo,
        nextChangeAvailableDate: currentCourse.nextChangeAvailableDate
      } : null
    });
  } catch (error) {
    console.error('マイページ情報取得エラー:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

**API-3: コース変更申請送信**

**エンドポイント**: `POST /api/career-course/change-request`

**実装ファイル**: `src/app/api/career-course/change-request/route.ts`（新規作成）

```typescript
// src/app/api/career-course/change-request/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { sendMail } from '@/lib/mail';

export async function POST(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');
    const body = await request.json();

    const {
      currentCourseCode,
      requestedCourseCode,
      changeReason,
      reasonDetail,
      requestedEffectiveDate,
      attachments
    } = body;

    // バリデーション
    if (currentCourseCode === requestedCourseCode) {
      return NextResponse.json({
        success: false,
        error: '現在のコースと同じコースは選択できません'
      }, { status: 400 });
    }

    // 年1回制限チェック（特例除く）
    if (changeReason === 'annual') {
      const currentSelection = await prisma.careerCourseSelection.findFirst({
        where: { employeeId: userId, effectiveTo: null }
      });

      if (currentSelection?.nextChangeAvailableDate &&
          new Date(currentSelection.nextChangeAvailableDate) > new Date()) {
        return NextResponse.json({
          success: false,
          error: `次回変更可能日は${currentSelection.nextChangeAvailableDate}です`
        }, { status: 400 });
      }
    }

    // 特例変更の場合、添付ファイル必須
    if (changeReason.startsWith('special_') && (!attachments || attachments.length === 0)) {
      return NextResponse.json({
        success: false,
        error: '特例変更には証明書類の添付が必要です'
      }, { status: 400 });
    }

    // 申請作成
    const request = await prisma.careerCourseChangeRequest.create({
      data: {
        employeeId: userId,
        currentCourseCode,
        requestedCourseCode,
        changeReason,
        reasonDetail,
        requestedEffectiveDate: new Date(requestedEffectiveDate),
        attachments: JSON.stringify(attachments),
        approvalStatus: 'pending'
      }
    });

    // 人事部へメール通知
    await sendMail({
      to: 'hr@medical-system.local',
      subject: '【新規】コース変更申請（職員名）',
      body: `コース変更申請がありました。\n\n申請ID: ${request.id}\n...`
    });

    // 申請者へ受付確認メール
    const employee = await prisma.employee.findUnique({ where: { id: userId } });
    await sendMail({
      to: employee.email,
      subject: 'コース変更申請を受け付けました',
      body: `申請を受け付けました。人事部の審査をお待ちください。\n\n申請ID: ${request.id}\n...`
    });

    return NextResponse.json({
      success: true,
      id: request.id,
      staffId: userId,
      approvalStatus: 'pending',
      message: 'コース変更申請を受け付けました。人事部の審査をお待ちください。'
    });
  } catch (error) {
    console.error('コース変更申請エラー:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

**API-4: 添付ファイルアップロード**

**エンドポイント**: `POST /api/career-course/upload-attachment`

**実装ファイル**: `src/app/api/career-course/upload-attachment/route.ts`（新規作成）

```typescript
// src/app/api/career-course/upload-attachment/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const s3Client = new S3Client({
  region: 'ap-northeast-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  }
});

export async function POST(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');
    const formData = await request.formData();
    const file = formData.get('file') as File;

    // バリデーション
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      return NextResponse.json({
        success: false,
        error: 'ファイルサイズは10MB以下にしてください'
      }, { status: 400 });
    }

    const allowedExtensions = ['.pdf', '.jpg', '.jpeg', '.png'];
    const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
    if (!allowedExtensions.includes(ext)) {
      return NextResponse.json({
        success: false,
        error: '許可されていないファイル形式です（.pdf, .jpg, .png のみ）'
      }, { status: 400 });
    }

    // ファイル名サニタイズ
    const timestamp = Date.now();
    const employee = await prisma.employee.findUnique({ where: { id: userId } });
    const sanitizedFileName = `${employee.employeeCode}_${timestamp}_${file.name}`;
    const key = `career-course-attachments/${sanitizedFileName}`;

    // S3アップロード
    const buffer = await file.arrayBuffer();
    await s3Client.send(new PutObjectCommand({
      Bucket: 'medical-system-career-attachments',
      Key: key,
      Body: Buffer.from(buffer),
      ContentType: file.type,
      ServerSideEncryption: 'AES256'
    }));

    // CloudFront署名付きURL生成（有効期限30日）
    const signedUrl = await getSignedUrl(s3Client, new GetObjectCommand({
      Bucket: 'medical-system-career-attachments',
      Key: key
    }), { expiresIn: 30 * 24 * 60 * 60 }); // 30日

    const fileUrl = `https://cdn.medical-system.local/attachments/${sanitizedFileName}`;

    return NextResponse.json({
      success: true,
      fileUrl,
      fileName: file.name,
      fileSize: file.size,
      uploadedAt: new Date().toISOString(),
      signedUrl,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
    });
  } catch (error) {
    console.error('ファイルアップロードエラー:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

#### 6.7.5 S3/CloudFront構築（Week 1: Day 5）

**S3バケット作成**:
```bash
# AWS CLI
aws s3 mb s3://medical-system-career-attachments --region ap-northeast-1

# バケットポリシー設定（プライベート）
aws s3api put-bucket-policy \
  --bucket medical-system-career-attachments \
  --policy file://bucket-policy.json

# 暗号化設定
aws s3api put-bucket-encryption \
  --bucket medical-system-career-attachments \
  --server-side-encryption-configuration '{
    "Rules": [{
      "ApplyServerSideEncryptionByDefault": {
        "SSEAlgorithm": "AES256"
      }
    }]
  }'

# ライフサイクルポリシー設定（3年後削除）
aws s3api put-bucket-lifecycle-configuration \
  --bucket medical-system-career-attachments \
  --lifecycle-configuration '{
    "Rules": [{
      "Id": "DeleteAfter3Years",
      "Status": "Enabled",
      "Expiration": { "Days": 1095 }
    }]
  }'

# CORS設定
aws s3api put-bucket-cors \
  --bucket medical-system-career-attachments \
  --cors-configuration '{
    "CORSRules": [{
      "AllowedOrigins": ["https://voicedrive-v100.vercel.app"],
      "AllowedMethods": ["POST"],
      "AllowedHeaders": ["*"]
    }]
  }'
```

**CloudFront設定**:
```bash
# CloudFrontディストリビューション作成
aws cloudfront create-distribution \
  --origin-domain-name medical-system-career-attachments.s3.ap-northeast-1.amazonaws.com \
  --default-root-object index.html

# 署名付きURL設定有効化
# AWS CloudFrontコンソールから設定
```

#### 6.7.6 単体テスト（Week 1: Day 6-7）

**テストファイル**: `tests/api/career-course/*.test.ts`（新規作成）

```bash
# 全APIテスト
npm run test:career-course

# 個別テスト
npx jest tests/api/career-course/definitions.test.ts
npx jest tests/api/career-course/change-request.test.ts
npx jest tests/api/career-course/upload-attachment.test.ts
```

#### 6.7.7 VoiceDrive統合テスト（Week 2: Day 1-2）

**VoiceDrive側のTODO実装**:
```typescript
// VoiceDrive: src/pages/career-selection-station/ChangeRequestPage.tsx
// TODO: 添付ファイルのアップロード処理（115-117行目）

// 実装後:
const attachmentUrls = await Promise.all(
  attachments.map(async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    const response = await fetch(`${API_BASE_URL}/api/career-course/upload-attachment`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${getAuthToken()}` },
      body: formData
    });
    const data = await response.json();
    return data.fileUrl;
  })
);
```

**統合テスト実行**:
```bash
# E2Eテスト（VoiceDrive UI → 医療システムAPI）
npm run test:e2e:career-course
```

#### 6.7.8 人事部管理画面実装（Week 3: Day 1-5）

**必要なUI**:
1. 申請一覧画面（`src/app/hr/career-course/requests/page.tsx`）
2. 申請詳細画面（`src/app/hr/career-course/requests/[id]/page.tsx`）
3. 審査・承認画面（同上）

**承認処理API**: `PUT /api/career-course/requests/:id/approve`

```typescript
// src/app/api/career-course/requests/[id]/approve/route.ts
export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    const { reviewComment } = await request.json();
    const reviewerId = request.headers.get('x-user-id');

    // 申請取得
    const changeRequest = await prisma.careerCourseChangeRequest.findUnique({
      where: { id: params.id }
    });

    // トランザクション処理
    await prisma.$transaction(async (tx) => {
      // 1. 申請ステータス更新
      await tx.careerCourseChangeRequest.update({
        where: { id: params.id },
        data: {
          approvalStatus: 'approved',
          reviewedAt: new Date(),
          hrReviewerId: reviewerId,
          reviewComment
        }
      });

      // 2. 現在のコースを終了
      await tx.careerCourseSelection.updateMany({
        where: {
          employeeId: changeRequest.employeeId,
          effectiveTo: null
        },
        data: {
          effectiveTo: new Date(changeRequest.requestedEffectiveDate)
        }
      });

      // 3. 新しいコースを開始
      await tx.careerCourseSelection.create({
        data: {
          employeeId: changeRequest.employeeId,
          courseCode: changeRequest.requestedCourseCode,
          effectiveFrom: new Date(changeRequest.requestedEffectiveDate),
          effectiveTo: null,
          nextChangeAvailableDate: new Date(
            new Date(changeRequest.requestedEffectiveDate).setFullYear(
              new Date(changeRequest.requestedEffectiveDate).getFullYear() + 1
            )
          ),
          approvedBy: reviewerId,
          approvalStatus: 'approved'
        }
      });
    });

    // 4. 申請者へメール通知
    const employee = await prisma.employee.findUnique({ where: { id: changeRequest.employeeId } });
    await sendMail({
      to: employee.email,
      subject: 'コース変更申請が承認されました',
      body: `${changeRequest.requestedCourseCode}コースへの変更が承認されました。\n\n適用日: ${changeRequest.requestedEffectiveDate}\n\nコメント: ${reviewComment}`
    });

    return NextResponse.json({
      success: true,
      message: '承認処理が完了しました'
    });
  } catch (error) {
    console.error('承認処理エラー:', error);
    return NextResponse.json({
      success: false,
      error: 'サーバーエラーが発生しました'
    }, { status: 500 });
  }
}
```

#### 6.7.9 実装チェックリスト

**Week 1: 基盤構築**
- [ ] DB実装（3テーブル）
- [ ] 初期データ投入（A/B/C/Dコース）
- [ ] API実装（4エンドポイント）
- [ ] S3/CloudFront構築
- [ ] 単体テスト（全API）

**Week 2: VoiceDrive統合**
- [ ] VoiceDrive側TODO実装
- [ ] E2Eテスト

**Week 3: 人事部管理画面**
- [ ] 申請一覧画面
- [ ] 申請詳細画面
- [ ] 審査・承認画面
- [ ] 承認処理API
- [ ] 却下処理API

#### 6.7.10 関連ドキュメント

- 医療システム確認結果: `mcp-shared/docs/career-course-change_医療システム確認結果_20251021.md`
- VoiceDrive 暫定マスターリスト: 受領済み（2025年10月21日）
- データ管理責任分界点定義書: `mcp-shared/docs/データ管理責任分界点定義書_20251008.md`

#### 6.7.11 VoiceDriveチームへの確認事項

以下の確認事項をVoiceDriveチームに確認する必要があります：

1. **キャリア選択制度の詳細仕様**
   - コース変更は年1回のみで確定か？
   - 特例変更（妊娠・介護・疾病）の場合、年1回制限は適用外か？
   - 承認権限は人事部のみか？施設ごとに承認者がいるか？
   - 承認フローは1段階（人事部のみ）か？複数段階か？

2. **添付ファイルの仕様**
   - 保存期間は何年か？（推奨: 3年）
   - アクセス権限は誰か？（推奨: 本人 + 人事部のみ）
   - ファイルサイズ制限は？（推奨: 10MB）
   - 許可する拡張子は？（推奨: .pdf, .jpg, .png）

3. **通知・メール送信の仕様**
   - 申請受付時に申請者へメール送信するか？
   - 新規申請時に人事部へメール送信するか？
   - 承認・却下時に申請者へメール送信するか？
   - VoiceDriveへのWebhook通知は必要か？（オプション）

#### 6.7.12 Phase 5-4 実装スケジュール（確定版）

**実装期間**: 2025年10月28日（月）～ 11月8日（金）（実働7日）

**VoiceDrive側との合意事項**:
- ✅ UI実装: VoiceDrive側が提供
- ✅ テーブル名: 医療システム側の命名規則を採用（`course_definitions`等）
- ✅ ファイルストレージ: Supabase Storage使用

**参照文書**:
- 医療システム確認結果: `mcp-shared/docs/career-course-change_医療システム確認結果_20251021.md`
- VoiceDrive回答: `mcp-shared/docs/career-course-change_VoiceDrive回答_20251021.md`（仮）
- 追加質問回答: `mcp-shared/docs/career-course-change_追加質問への回答_20251021.md`

##### Phase 5-4a: DB構築（10/28-10/29、2日）

**担当**: 医療システムチーム
**VoiceDrive参加**: ❌ 不要

**作業内容**:
1. schema.prismaへのモデル追加
   - `CareerCourseDefinition`
   - `StaffCareerCourse`
   - `CareerCourseChangeRequest`

2. マイグレーション実行
   ```bash
   npx prisma migrate dev --name add_career_course_tables
   npx prisma migrate deploy
   ```

3. 初期データ投入
   ```bash
   npx tsx scripts/seed-career-courses.ts
   ```

**完了基準**:
- [ ] 3テーブル作成完了
- [ ] A/B/C/D 4コース定義投入完了
- [ ] マイグレーション成功

**完了予定**: 10/29（火）17:00

##### Phase 5-4b: API実装（10/30-11/1、3日）

**担当**: 医療システムチーム
**VoiceDrive参加**: ❌ 不要

**作業内容**:
1. API実装（4エンドポイント）
   - `GET /api/career-courses/definitions`
   - `GET /api/my-page`（careerCourse追加）
   - `POST /api/career-course/change-request`
   - `GET /api/career-course/my-requests`

2. 認証実装
   - Supabase JWT検証
   - SystemAccount連携

3. バリデーション実装
   - 年1回制限チェック
   - 特例変更の添付ファイル必須チェック

**完了基準**:
- [ ] 全API動作確認完了
- [ ] 認証フロー確認完了
- [ ] 単体テスト実施完了

**完了予定**: 11/1（金）17:00

##### Phase 5-4c: ファイルストレージ統合（11/4-11/5、2日）

**担当**: 医療システムチーム
**VoiceDrive参加**: ❌ 不要

**作業内容**:
1. Supabase Storage設定
   - バケット作成: `career-course-attachments`
   - RLS（Row Level Security）設定
   - アクセス権限設定

2. API実装
   - `POST /api/career-course/upload-attachment`

3. ファイル処理実装
   - ファイルサイズチェック（最大10MB）
   - 拡張子チェック（.pdf, .jpg, .png）
   - ウイルススキャン（オプション）

**完了基準**:
- [ ] ファイルアップロード動作確認
- [ ] RLS動作確認
- [ ] 署名付きURL生成確認

**完了予定**: 11/5（火）17:00

##### Phase 5-4d: 統合テスト（11/6-11/8、3日）

**担当**: 医療システムチーム + VoiceDriveチーム
**VoiceDrive参加**: ✅ **参加必須**

**11/6（水）9:00 - 統合テストキックオフ**

**参加者**:
- VoiceDriveチーム: プロジェクトリード、技術担当
- 医療システムチーム: API担当、テスト担当

**アジェンダ**:
1. API仕様の最終確認
2. 認証フロー確認
3. エラーハンドリング確認
4. テストシナリオ共有

**11/7（木）終日 - 統合テスト実施**

**テスト内容**:
1. コース変更申請フロー（正常系）
2. ファイルアップロード
3. バリデーションエラー
4. 認証エラー
5. ネットワークエラー

**VoiceDrive側の作業**:
- `ChangeRequestPage.tsx` のAPI接続
- エラーハンドリングの実装
- ローディング状態の実装

**11/8（金）15:00 - 統合テスト完了報告**

**成果物**:
- 統合テスト報告書
- 既知の問題リスト
- リリース判定

**完了基準**:
- [ ] 全テストシナリオ実施完了
- [ ] VoiceDrive側UI接続確認
- [ ] パフォーマンステスト完了

**完了予定**: 11/8（金）17:00

##### Phase 5-4 チェックリスト

**医療システム側**:
- [ ] Phase 5-4a: DB構築完了（10/29）
- [ ] Phase 5-4b: API実装完了（11/1）
- [ ] Phase 5-4c: ファイルストレージ統合完了（11/5）
- [ ] Phase 5-4d: 統合テスト完了（11/8）
- [ ] API仕様書作成（OpenAPI 3.0）
- [ ] Dev環境URL提供

**VoiceDrive側**:
- [ ] スケジュール確認（11/6-11/8参加可否）
- [ ] テーブル名修正（型定義更新）
- [ ] Supabase Storage設定確認
- [ ] 統合テスト参加（11/6-11/8）

---

### 6.8 Phase 8: 承認・対応管理API実装（Approvals連携）

**実装時期**: 共通DB構築後（VoiceDrive Phase 1-4と並行）
**優先度**: 🟡 中優先度
**参照文書**: `mcp-shared/docs/approvals_医療システム確認結果_20251021.md`

#### 6.8.1 実装概要

VoiceDrive側の承認・対応管理ページ（ApprovalsPage）でエスカレーション機能・予算承認機能を実現するためのAPI実装。

**データ管理責任**:
- 通知・承認タスクデータ: ❌ VoiceDrive 100%管轄
- 組織階層情報: ✅ 医療システム管轄
- 予算承認限度額: ✅ 医療システム管轄

#### 6.8.2 DB拡張（Day 1）

**Employeeテーブルにフィールド追加**:

```prisma
model Employee {
  // ... 既存フィールド
  budgetApprovalLimit Int? // 予算承認限度額（円）
}
```

**マイグレーション実行**:
```bash
# schema.prismaを更新
npx prisma format
npx prisma migrate dev --name add_budget_approval_limit

# 本番環境
npx prisma migrate deploy
```

**初期値設定スクリプト**:
```sql
-- Level別の予算承認限度額設定
UPDATE employees SET budgetApprovalLimit = NULL WHERE permissionLevel <= 5;
UPDATE employees SET budgetApprovalLimit = 100000 WHERE permissionLevel IN (6, 7);
UPDATE employees SET budgetApprovalLimit = 500000 WHERE permissionLevel IN (8, 9);
UPDATE employees SET budgetApprovalLimit = 2000000 WHERE permissionLevel = 10;
UPDATE employees SET budgetApprovalLimit = 5000000 WHERE permissionLevel = 11;
UPDATE employees SET budgetApprovalLimit = 10000000 WHERE permissionLevel >= 12;
```

#### 6.8.3 API実装（Day 2-3）

**API-1: 組織階層取得API**

**エンドポイント**: `GET /api/v2/employees/:employeeId/hierarchy`

**実装ファイル**: `src/app/api/v2/employees/[employeeId]/hierarchy/route.ts`（新規作成）

```typescript
// src/app/api/v2/employees/[employeeId]/hierarchy/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: { employeeId: string } }
) {
  const { employeeId } = params;
  const { searchParams } = new URL(request.url);
  const depth = parseInt(searchParams.get('depth') || '2');

  try {
    // 対象職員取得
    const employee = await prisma.employee.findUnique({
      where: { id: employeeId },
      include: {
        position: true,
        department: true,
      },
    });

    if (!employee) {
      return NextResponse.json(
        { error: 'Employee not found' },
        { status: 404 }
      );
    }

    const hierarchy: any = {
      employee: {
        id: employee.id,
        name: employee.name,
        permissionLevel: employee.permissionLevel,
        accountType: employee.position.accountType,
        department: employee.department.name,
        budgetApprovalLimit: employee.budgetApprovalLimit,
      },
    };

    // 上位者取得（depth分）
    let currentSupervisorId = employee.supervisorId;
    let level = 1;

    while (currentSupervisorId && level <= depth) {
      const supervisor = await prisma.employee.findUnique({
        where: { id: currentSupervisorId },
        include: {
          position: true,
          department: true,
        },
      });

      if (!supervisor) break;

      const key = level === 1 ? 'parent' : level === 2 ? 'grandparent' : `level${level}`;
      hierarchy[key] = {
        id: supervisor.id,
        name: supervisor.name,
        permissionLevel: supervisor.permissionLevel,
        accountType: supervisor.position.accountType,
        department: supervisor.department.name,
        budgetApprovalLimit: supervisor.budgetApprovalLimit,
      };

      currentSupervisorId = supervisor.supervisorId;
      level++;
    }

    return NextResponse.json(hierarchy);
  } catch (error) {
    console.error('Error fetching employee hierarchy:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Response例**:
```json
{
  "employee": {
    "id": "OH-NS-2024-020",
    "name": "田中看護師長",
    "permissionLevel": 8.0,
    "accountType": "DEPARTMENT_HEAD",
    "department": "医療療養病棟",
    "budgetApprovalLimit": 500000
  },
  "parent": {
    "id": "OH-NS-2024-030",
    "name": "山田部長",
    "permissionLevel": 10.0,
    "accountType": "DEPARTMENT_DIRECTOR",
    "department": "看護部",
    "budgetApprovalLimit": 2000000
  },
  "grandparent": {
    "id": "OH-NS-2024-040",
    "name": "佐藤事務長",
    "permissionLevel": 11.0,
    "accountType": "DIRECTOR",
    "department": "事務部",
    "budgetApprovalLimit": 5000000
  }
}
```

#### 6.8.4 単体テスト（Day 4）

**テストファイル**: `tests/api/v2/employees/hierarchy.test.ts`（新規作成）

```typescript
import { describe, test, expect } from '@jest/globals';

describe('GET /api/v2/employees/:employeeId/hierarchy', () => {
  test('正常系: 組織階層を取得できる', async () => {
    const response = await fetch('/api/v2/employees/OH-NS-2024-020/hierarchy');
    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.employee).toBeDefined();
    expect(data.parent).toBeDefined();
    expect(data.employee.budgetApprovalLimit).toBe(500000);
  });

  test('正常系: depth=1で直属の上司のみ取得', async () => {
    const response = await fetch('/api/v2/employees/OH-NS-2024-020/hierarchy?depth=1');
    const data = await response.json();
    expect(data.parent).toBeDefined();
    expect(data.grandparent).toBeUndefined();
  });

  test('異常系: 存在しない職員IDで404エラー', async () => {
    const response = await fetch('/api/v2/employees/invalid-id/hierarchy');
    expect(response.status).toBe(404);
  });

  test('正常系: budgetApprovalLimitが正しく返却される', async () => {
    const response = await fetch('/api/v2/employees/OH-NS-2024-020/hierarchy');
    const data = await response.json();
    expect(typeof data.employee.budgetApprovalLimit).toBe('number');
  });
});
```

**実行**:
```bash
npx jest tests/api/v2/employees/hierarchy.test.ts
```

#### 6.8.5 VoiceDrive統合テスト（Day 5）

**VoiceDrive側の使用例**:
```typescript
// VoiceDrive側のエスカレーション処理
async function escalateApprovalTask(taskId: string) {
  // 現在の承認者取得
  const task = await prisma.approvalTask.findUnique({ where: { id: taskId } });

  // 医療システムAPIから組織階層取得
  const hierarchy = await fetch(
    `https://medical.example.com/api/v2/employees/${task.approverId}/hierarchy?depth=1`,
    {
      headers: {
        'X-API-Key': process.env.MEDICAL_SYSTEM_API_KEY!,
      },
    }
  ).then((res) => res.json());

  if (!hierarchy.parent) {
    throw new Error('上位承認者が存在しません');
  }

  // 上位承認者にエスカレーション
  await prisma.approvalTask.update({
    where: { id: taskId },
    data: {
      approverId: hierarchy.parent.id,
      escalatedFrom: task.approverId,
      escalatedAt: new Date(),
    },
  });

  // 通知作成
  await createNotification({
    recipientId: hierarchy.parent.id,
    type: 'ESCALATION',
    title: `承認期限切れ: ${task.title}`,
    message: `${task.requesterName}からの承認依頼がエスカレートされました`,
  });
}
```

**統合テスト項目**:
1. VoiceDrive側から組織階層API呼び出し成功
2. エスカレーション処理の動作確認
3. 予算承認限度額による承認者判定の動作確認

#### 6.8.6 実装スケジュール

| 日付 | 作業内容 | 担当 | 状態 |
|------|---------|------|------|
| **Day 1** | budgetApprovalLimitフィールド追加 | 医療チーム | ⏳ VoiceDrive Phase 1完了後 |
| **Day 2** | 組織階層API実装 | 医療チーム | ⏳ VoiceDrive Phase 1完了後 |
| **Day 3** | API実装完了・動作確認 | 医療チーム | ⏳ VoiceDrive Phase 1完了後 |
| **Day 4** | 単体テスト | 医療チーム | ⏳ VoiceDrive Phase 1完了後 |
| **Day 5** | VoiceDrive統合テスト | 両チーム | ⏳ VoiceDrive Phase 1完了後 |

**推定工数**: 0.8日（約6-7時間）

#### 6.8.7 成功基準

- ✅ budgetApprovalLimitフィールド追加完了
- ✅ 初期値設定完了（Level別）
- ✅ 組織階層API実装完了
- ✅ 単体テスト全て成功
- ✅ VoiceDrive側からのAPI呼び出し成功
- ✅ エスカレーション機能動作確認
- ✅ 予算承認限度額判定動作確認

#### 6.8.8 VoiceDrive側の実装スケジュール（参考）

| Phase | 期間 | 内容 |
|-------|------|------|
| Phase 1 | 1-2日 | データベース拡張（Notification, NotificationAction, NotificationRecipient） |
| Phase 2 | 2-3日 | NotificationService実装 |
| Phase 3 | 2-3日 | API実装（GET /api/notifications等） |
| Phase 4 | 1-2日 | 統合テスト |

**合計**: 6-10日

#### 6.8.9 関連ドキュメント

- 医療システム確認結果: `mcp-shared/docs/approvals_医療システム確認結果_20251021.md`
- VoiceDrive 暫定マスターリスト: `MASTER-APPROVALS-20251013-001`
- データ管理責任分界点定義書: `mcp-shared/docs/データ管理責任分界点定義書_20251008.md`

---

### 6.9 ProfilePage API統合テスト

**概要**:
ProfilePageは、PersonalStationと同様のAPI（`GET /api/v2/employees/{employeeId}`, `GET /api/v2/employees/{employeeId}/experience-summary`）を使用し、追加でスキル情報API（`GET /api/v2/employees/{employeeId}/skills`）が必要。

**前提条件**:
- ✅ API-1, API-2実装完了（PersonalStation実装時に完了済み）
- ⏳ API-3（スキル情報API）実装待ち（EmployeeSkillテーブル確認後）
- ✅ 確認結果報告書作成済み（mcp-shared/docs/ProfilePage_医療システム確認結果_20251024.md）

#### 6.9.1 環境変数設定
```bash
# .env.productionに追加（PersonalStationと同じAPI Keyを使用）
PROFILE_PAGE_API_KEY=${PERSONAL_STATION_API_KEY}

# VoiceDrive側の設定確認（VoiceDriveチームに共有）
# MEDICAL_SYSTEM_API_URL=https://medical.example.com/api/v2
# MEDICAL_SYSTEM_API_KEY=[PersonalStationと同じAPI Key]
```

#### 6.9.2 実データでAPI動作確認
```bash
# API-1: 職員基本情報取得テスト
curl -X GET "http://localhost:3000/api/v2/employees/EMP2024001" \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"

# 期待されるレスポンス:
# {
#   "employeeId": "EMP2024001",
#   "employeeNumber": "EMP-2024-001",
#   "name": "山田 太郎",
#   "nameKana": "ヤマダ タロウ",
#   "email": "yamada.taro@hospital.local",
#   "department": "外科",
#   "facilityId": "FAC001",
#   "profession": "看護師",
#   "position": "主任",
#   "hireDate": "2018-04-01",
#   "permissionLevel": 3.5,
#   "avatar": "https://cdn.hospital.local/avatars/emp2024001.jpg",
#   "isRetired": false
# }

# API-2: 経験年数サマリー取得テスト
curl -X GET "http://localhost:3000/api/v2/employees/EMP2024001/experience-summary" \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"

# 期待されるレスポンス:
# {
#   "employeeId": "EMP2024001",
#   "yearsOfService": 6.0,
#   "totalExperienceYears": 9.0,
#   "previousExperience": 3.0,
#   "currentPositionYears": 2.1,
#   "calculatedAt": "2025-10-24T10:30:00Z"
# }

# API-3: スキル情報取得テスト（Phase 2実装後）
curl -X GET "http://localhost:3000/api/v2/employees/EMP2024001/skills" \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"

# Phase 1レスポンス（EmployeeSkillテーブル未実装時）:
# {
#   "employeeId": "EMP2024001",
#   "skills": [],
#   "totalSkillCount": 0,
#   "averageLevel": 0,
#   "calculatedAt": "2025-10-24T10:30:00Z",
#   "note": "EmployeeSkillテーブル実装待ち（Phase 2予定）"
# }

# Phase 2レスポンス（EmployeeSkillテーブル実装後）:
# {
#   "employeeId": "EMP2024001",
#   "skills": [
#     {
#       "skillId": "SKL001",
#       "skillName": "脳血管リハビリ",
#       "skillCategory": "rehabilitation",
#       "level": 4,
#       "certificationDate": "2020-03-15"
#     },
#     {
#       "skillId": "SKL002",
#       "skillName": "チーム医療",
#       "skillCategory": "teamwork",
#       "level": 5,
#       "certificationDate": "2019-08-20"
#     }
#   ],
#   "totalSkillCount": 2,
#   "averageLevel": 4.5,
#   "calculatedAt": "2025-10-24T10:30:00Z"
# }
```

#### 6.9.3 エラーハンドリングテスト
```bash
# 401 Unauthorized（JWT Token未提供）
curl -X GET "http://localhost:3000/api/v2/employees/EMP2024001" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"
# 期待: {"error":{"code":"UNAUTHORIZED","message":"JWT Token is required"}}

# 403 Forbidden（他職員のスキル情報取得、Level 1-6）
curl -X GET "http://localhost:3000/api/v2/employees/EMP2024002/skills" \
  -H "Authorization: Bearer ${JWT_TOKEN_LEVEL_3}" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"
# 期待: {"error":{"code":"FORBIDDEN","message":"Insufficient permission to view other employee's skills"}}

# 404 Not Found（存在しない職員ID）
curl -X GET "http://localhost:3000/api/v2/employees/INVALID_ID" \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "X-API-Key: ${PROFILE_PAGE_API_KEY}"
# 期待: {"error":{"code":"NOT_FOUND","message":"Employee not found"}}

# 429 Rate Limit超過テスト（100回超過でエラー）
for i in {1..105}; do
  curl -X GET "http://localhost:3000/api/v2/employees/EMP2024001" \
    -H "Authorization: Bearer ${JWT_TOKEN}" \
    -H "X-API-Key: ${PROFILE_PAGE_API_KEY}" \
    -H "X-Forwarded-For: 192.168.1.100"
done
# 101回目以降: {"error":{"code":"RATE_LIMIT_EXCEEDED","message":"Too many requests"}}
```

#### 6.9.4 VoiceDriveチームとの統合テスト
```bash
# VoiceDriveチームに以下を共有:
# - APIエンドポイントURL: https://medical.example.com/api/v2
# - ProfilePage用APIキー: [PersonalStationと同じAPI Key]
# - API仕様書: mcp-shared/docs/ProfilePage_医療システム確認結果_20251024.md

# VoiceDriveチーム側での確認事項:
# 1. ProfilePageでプロフィールヘッダーが正常に表示されるか確認
# 2. 経験年数（勤続年数、前職経験、総経験年数）が正常に表示されるか確認
# 3. スキル情報が正常に表示されるか確認（Phase 2実装後）
# 4. 自分のプロフィールのみ編集可能か確認
```

#### 6.9.5 統合テスト完了基準
- [ ] API-1（職員基本情報）が実データで正常動作
- [ ] API-2（経験年数サマリー）が実データで正常動作
- [ ] API-3（スキル情報）がPhase 1レスポンス（空配列）を返す
- [ ] VoiceDrive ProfilePageでプロフィール情報が正常表示
- [ ] 権限レベル別のアクセス制御が正常動作
- [ ] Rate Limitが正常動作

**推定工数**: 1日間（DB構築後、Phase 1のみ）
**Phase 2工数**: 0.5日間（EmployeeSkillテーブル実装後、API-3実装）

**関連ドキュメント**:
- 確認結果報告書: `mcp-shared/docs/ProfilePage_医療システム確認結果_20251024.md`（✅ 完成）
- 要件定義: `mcp-shared/docs/ProfilePage暫定マスターリスト_20251024.md`（VoiceDrive提供）
- DB要件分析: `mcp-shared/docs/ProfilePage_DB要件分析_20251024.md`（VoiceDrive提供）

**実装済みファイル**:
- `src/app/api/v2/employees/[employeeId]/route.ts` - 職員基本情報API（PersonalStation実装時に完了）
- `src/app/api/v2/employees/[employeeId]/experience-summary/route.ts` - 経験年数API（PersonalStation実装時に完了）
- `src/app/api/v2/employees/[employeeId]/skills/route.ts` - スキル情報API（Phase 2実装予定）

---

## 7. Step 6: 本番デプロイ準備

### 7.1 最終確認
```bash
# 全テストスイート実行
npm run test:all:production

# パフォーマンステスト
npm run test:performance
```

### 7.2 デプロイチェックリスト
- [ ] 全テスト合格（32/32）
- [ ] VoiceDrive連携確認済み
- [ ] バックアップ作成済み
- [ ] ロールバック手順確認済み
- [ ] 監視設定完了

---

## 8. Step 7: 本番デプロイ

### 8.1 デプロイコマンド
```bash
# ビルド
npm run build:production

# デプロイ
npm run deploy:production

# ヘルスチェック
npm run health:check
```

### 8.2 デプロイ後確認
```bash
# ログ監視
npm run logs:production

# メトリクス確認
npm run metrics:check
```

---

## 9. トラブルシューティング

### よくある問題と対処法

#### 問題1: 統括主任のレベルが6になっている
```javascript
// facility-position-mapping.tsの63行目を確認
{ positionName: '統括主任', baseLevel: 7, ... }  // 7であることを確認
```

#### 問題2: 兼任職員の権限が低い方で適用される
```javascript
// 権限取得ロジックを確認
const effectiveLevel = Math.max(position1Level, position2Level);
```

#### 問題3: エスポワール立神が認識されない
```bash
# 施設IDを確認
echo $DEFAULT_FACILITY_ID  # espoir-tategami であること
```

---

## 10. 連絡先

### 緊急時連絡先
- インフラチーム: [連絡先]
- VoiceDriveチーム: [連絡先]
- DB管理者: [連絡先]

### ドキュメント参照
- 作業完了報告書: `/docs/エスポワール立神統合_作業完了報告書_20250928.md`
- VoiceDrive連携仕様: `/docs/20250928_エスポワール立神統合連絡書.md`
- テスト結果: `/docs/統合テスト実施記録_20250928.md`

---

## 11. 作業完了基準

以下が全て完了したら作業完了とする:

1. ✅ DB接続確認
2. ✅ マスターデータ投入完了
3. ✅ 統合テスト全項目合格
4. ✅ VoiceDrive連携確認
   - [ ] Webhook疎通確認
   - [ ] データ同期テスト
   - [ ] OrganizationAnalytics API統合テスト
   - [ ] ExecutiveReports API統合テスト（2025年10月25日予定）
   - [ ] BoardPreparation VoiceDrive実装確認（タスク1-4）
   - [ ] Strategic HR Plan API統合テスト（Phase 1）
   - [ ] 委員会マスタAPI統合テスト（Phase 3: 2025年11月15日予定）
   - [x] **Phase 5-4（キャリアコース変更申請）DB構築前調整完了**（2025年10月21日完了）
5. ✅ 本番環境デプロイ完了
6. ✅ 24時間の安定稼働確認

---

**重要**: 作業中に問題が発生した場合は、すぐに関係チームに連絡し、
ロールバック判断を仰ぐこと。

---

作成者: 医療職員管理システム開発チーム
作成日: 2025年9月28日
最終更新: 2025年10月21日（Phase 7: キャリアコース変更申請機能 追加 - 6.7節）